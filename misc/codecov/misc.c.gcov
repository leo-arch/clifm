        -:    0:Source:misc.c
        -:    1:/* misc.c -- functions that do not fit in any other file */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <errno.h>
        -:   28:#include <fcntl.h>
        -:   29:#include <signal.h>
        -:   30:#include <stdarg.h>
        -:   31:#include <stdio.h>
        -:   32:#include <string.h>
        -:   33:#include <sys/stat.h>
        -:   34:#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
        -:   35:#include <sys/mount.h>
        -:   36:#include <sys/sysctl.h>
        -:   37:#endif
        -:   38:/*
        -:   39:#if defined(__HAIKU__)
        -:   40:#include <private/libs/compat/freebsd_network/compat/sys/mount.h>
        -:   41:#include <private/libs/compat/freebsd_network/compat/sys/sysctl.h>
        -:   42:#endif */
        -:   43:#include <time.h>
        -:   44:#include <unistd.h>
        -:   45:#include <readline/readline.h>
        -:   46:#ifdef LINUX_INOTIFY
        -:   47:#include <sys/inotify.h>
        -:   48:#endif
        -:   49:
        -:   50:#include "aux.h"
        -:   51:#include "bookmarks.h"
        -:   52:#include "checks.h"
        -:   53:#include "exec.h"
        -:   54:#include "history.h"
        -:   55:#include "init.h"
        -:   56:#include "jump.h"
        -:   57:#include "listing.h"
        -:   58:#include "navigation.h"
        -:   59:#include "readline.h"
        -:   60:#include "strings.h"
        -:   61:#include "remotes.h"
        -:   62:#include "messages.h"
        -:   63:
        -:   64:#ifdef LINUX_INOTIFY
        -:   65:void
function read_inotify called 48 returned 100% blocks executed 93%
       48:   66:read_inotify(void)
        -:   67:{
        -:   68:	int i;
        -:   69:	struct inotify_event *event;
        -:   70:	char inotify_buf[EVENT_BUF_LEN];
        -:   71:
       48:   72:	memset((void *)inotify_buf, '\0', EVENT_BUF_LEN);
       48:   73:	i = (int)read(inotify_fd, inotify_buf, EVENT_BUF_LEN);
       48:   73-block  0
call    0 returned 48
        -:   74:
       48:   75:	if (i <= 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 45
        3:   76:		return;
        3:   76-block  0
unconditional  0 taken 3
        -:   77:
       45:   78:	int ignore_event = 0, refresh = 0;
       45:   79:	for (char *ptr = inotify_buf;
       45:   79-block  0
unconditional  0 taken 45
      409:   80:	ptr + ((struct inotify_event *)ptr)->len < inotify_buf + i;
      409:   80-block  0
branch  0 taken 364
branch  1 taken 45 (fallthrough)
      364:   81:	ptr += sizeof(struct inotify_event) + event->len) {
      364:   81-block  0
unconditional  0 taken 364
      364:   82:		event = (struct inotify_event *)ptr;
      364:   83:		if (!event->wd)
      364:   83-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 364
    #####:   84:			break;
    %%%%%:   84-block  0
unconditional  0 never executed
        -:   85:
      364:   86:		if (event->mask & IN_CREATE) {
      364:   86-block  0
branch  0 taken 25 (fallthrough)
branch  1 taken 339
        -:   87:/*			puts("IN_CREATE"); */
        -:   88:			struct stat a;
       25:   89:			if (stat(event->name, &a) != 0)
       25:   89-block  0
call    0 returned 25
branch  1 taken 5 (fallthrough)
branch  2 taken 20
        -:   90:				/* The file was created, but doesn't exist anymore */
        5:   91:				ignore_event = 1;
        5:   91-block  0
unconditional  0 taken 5
        -:   92:		}
      364:   93:		if (event->mask & IN_DELETE) {
      364:   93-block  0
branch  0 taken 17 (fallthrough)
branch  1 taken 347
        -:   94:/*			puts("IN_DELETE"); */
        -:   95:			struct stat a;
       17:   96:			if (stat(event->name, &a) == 0)
       17:   96-block  0
call    0 returned 17
branch  1 taken 0 (fallthrough)
branch  2 taken 17
        -:   97:				/* The file was removed, but is still there */
    #####:   98:				ignore_event = 1;
    %%%%%:   98-block  0
unconditional  0 never executed
        -:   99:		}
        -:  100:/*		if (event->mask & IN_DELETE_SELF)
        -:  101:			puts("IN_DELETE_SELF");
        -:  102:		if (event->mask & IN_MOVE_SELF)
        -:  103:			puts("IN_MOVE_SELF");
        -:  104:		if (event->mask & IN_MOVED_FROM)
        -:  105:			puts("IN_MOVED_FROM");
        -:  106:		if (event->mask & IN_MOVED_TO)
        -:  107:			puts("IN_MOVED_TO");
        -:  108:		if (event->mask & IN_IGNORED) {
        -:  109:			puts("IN_IGNORED");
        -:  110:		} */
        -:  111:
      364:  112:		if (!ignore_event && (event->mask & INOTIFY_MASK))
      364:  112-block  0
branch  0 taken 342 (fallthrough)
branch  1 taken 22
      342:  112-block  1
branch  2 taken 57 (fallthrough)
branch  3 taken 285
       57:  113:			refresh = 1;
       57:  113-block  0
unconditional  0 taken 57
        -:  114:	}
        -:  115:
       45:  116:	if (refresh) {
       45:  116-block  0
branch  0 taken 26 (fallthrough)
branch  1 taken 19
       26:  117:		free_dirlist();
       26:  117-block  0
call    0 returned 26
       26:  118:		list_dir();
call    0 returned 26
unconditional  1 taken 26
        -:  119:	}
        -:  120:
       45:  121:	return;
       45:  121-block  0
unconditional  0 taken 45
        -:  122:}
        -:  123:#elif defined(BSD_KQUEUE)
        -:  124:void
        -:  125:read_kqueue(void)
        -:  126:{
        -:  127:	struct kevent event_data[NUM_EVENT_SLOTS];
        -:  128:	memset((void *)event_data, '\0', sizeof(struct kevent)
        -:  129:			* NUM_EVENT_SLOTS);
        -:  130:	int i, refresh = 0;
        -:  131:
        -:  132:	int count = kevent(kq, NULL, 0, event_data, 4096, &timeout);
        -:  133:
        -:  134:	for (i = 0; i < count; i++) {
        -:  135:/*		if (event_data[i].fflags & NOTE_DELETE)
        -:  136:			puts("NOTE_DELETE");
        -:  137:		if (event_data[i].fflags & NOTE_WRITE)
        -:  138:			puts("NOTE_WRITE");
        -:  139:		if (event_data[i].fflags & NOTE_EXTEND)
        -:  140:			puts("NOTE_EXTEND");
        -:  141:		if (event_data[i].fflags & NOTE_ATTRIB)
        -:  142:			puts("NOTE_ATTRIB");
        -:  143:		if (event_data[i].fflags & NOTE_LINK)
        -:  144:			puts("NOTE_LINK");
        -:  145:		if (event_data[i].fflags & NOTE_RENAME)
        -:  146:			puts("NOTE_RENAME");
        -:  147:		if (event_data[i].fflags & NOTE_REVOKE)
        -:  148:			puts("NOTE_REVOKE"); */
        -:  149:
        -:  150:		if (event_data[i].fflags & KQUEUE_FFLAGS) {
        -:  151:			refresh = 1;
        -:  152:			break;
        -:  153:		}
        -:  154:	}
        -:  155:
        -:  156:	if (refresh) {
        -:  157:		free_dirlist();
        -:  158:		if (list_dir() != EXIT_SUCCESS)
        -:  159:			exit_code = EXIT_FAILURE;
        -:  160:		return;
        -:  161:	}
        -:  162:
        -:  163:	if (event_fd >= 0) {
        -:  164:		close(event_fd);
        -:  165:		event_fd = -1;
        -:  166:		watch = 0;
        -:  167:	}
        -:  168:}
        -:  169:#endif
        -:  170:
        -:  171:void
function set_term_title called 613 returned 100% blocks executed 89%
      613:  172:set_term_title(const char *str)
        -:  173:{
      613:  174:	char *tmp = (char *)NULL;
      613:  175:	tmp = home_tilde(str);
      613:  175-block  0
call    0 returned 613
        -:  176:
     613*:  177:	printf("\033]2;%s - %s\007", PROGRAM_NAME, tmp ? tmp : str);
branch  0 taken 613 (fallthrough)
branch  1 taken 0
      613:  177-block  0
unconditional  2 taken 613
    %%%%%:  177-block  1
unconditional  3 never executed
      613:  177-block  2
call    4 returned 613
      613:  178:	fflush(stdout);
call    0 returned 613
        -:  179:
      613:  180:	if (tmp)
branch  0 taken 613 (fallthrough)
branch  1 taken 0
      613:  181:		free(tmp);
      613:  181-block  0
unconditional  0 taken 613
      613:  182:}
        -:  183:
        -:  184:int
function filter_function called 7 returned 100% blocks executed 85%
        7:  185:filter_function(const char *arg)
        -:  186:{
        7:  187:	if (!arg) {
        7:  187-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 5
       2*:  188:		printf(_("Current filter: %c%s\n"), filter_rev ? '!' : 0,
        1:  188-block  0
unconditional  0 taken 1
        1:  188-block  1
unconditional  1 taken 1
        2:  188-block  2
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    %%%%%:  188-block  3
unconditional  4 never executed
        2:  188-block  4
unconditional  5 taken 2
        2:  188-block  5
call    6 returned 2
call    7 returned 2
        2:  189:				filter ? filter : "none");
        2:  189-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        2:  190:		return EXIT_SUCCESS;
unconditional  0 taken 2
        -:  191:	}
        -:  192:
        5:  193:	if (*arg == '-' && strcmp(arg, "--help") == 0) {
        5:  193-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1:  193-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  194:		puts(_(FILTER_USAGE));
        1:  194-block  0
call    0 returned 1
call    1 returned 1
        1:  195:		return EXIT_SUCCESS;
unconditional  0 taken 1
        -:  196:	}
        -:  197:
        4:  198:	if (*arg == 'u' && strcmp(arg, "unset") == 0) {
        4:  198-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  198-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  199:		if (filter) {
        1:  199-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  200:			free(filter);
        1:  201:			filter = (char *)NULL;
        1:  202:			regfree(&regex_exp);
        1:  202-block  0
call    0 returned 1
        1:  203:			puts(_("Filter unset"));
call    0 returned 1
call    1 returned 1
        1:  204:			filter_rev = 0;
unconditional  0 taken 1
        -:  205:		} else {
    #####:  206:			puts(_("No filter set"));
    %%%%%:  206-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  207:		}
        -:  208:
        1:  209:		return EXIT_SUCCESS;
        1:  209-block  0
unconditional  0 taken 1
        -:  210:	}
        -:  211:
        3:  212:	if (filter)
        3:  212-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  213:		free(filter);
        2:  213-block  0
unconditional  0 taken 2
        -:  214:
        3:  215:	regfree(&regex_exp);
        3:  215-block  0
call    0 returned 3
        -:  216:
        3:  217:	if (*arg == '!') {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  218:		filter_rev = 1;
        1:  219:		arg++;
        1:  219-block  0
unconditional  0 taken 1
        -:  220:	} else {
        2:  221:		filter_rev = 0;
        2:  221-block  0
unconditional  0 taken 2
        -:  222:	}
        -:  223:
        3:  224:	filter = savestring(arg, strlen(arg));
        3:  224-block  0
call    0 returned 3
        -:  225:
        3:  226:	if (regcomp(&regex_exp, filter, REG_NOSUB | REG_EXTENDED) != EXIT_SUCCESS) {
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  227:		fprintf(stderr, _("%s: '%s': Invalid regular expression\n"),
    %%%%%:  227-block  0
call    0 never executed
call    1 never executed
        -:  228:		    PROGRAM_NAME, filter);
    #####:  229:		free(filter);
    #####:  230:		filter = (char *)NULL;
    #####:  231:		regfree(&regex_exp);
call    0 never executed
unconditional  1 never executed
        -:  232:	} else {
        3:  233:		puts(_("New filter successfully set"));
        3:  233-block  0
call    0 returned 3
call    1 returned 3
unconditional  2 taken 3
        -:  234:	}
        -:  235:
        3:  236:	return EXIT_SUCCESS;
        3:  236-block  0
unconditional  0 taken 3
        -:  237:}
        -:  238:
        -:  239:/* Print either all tips (if ALL == 1) or just a random one (ALL == 0) */
        -:  240:void
function print_tips called 5 returned 100% blocks executed 100%
        5:  241:print_tips(int all)
        -:  242:{
        5:  243:	const char *TIPS[] = {
        -:  244:	    "Try the autocd and auto-open functions: run 'FILE' instead "
        -:  245:	    "of 'open FILE' or 'cd FILE'",
        -:  246:	    "Add a new entry to the mimelist file with 'mm edit' or F6",
        -:  247:	    "Do not forget to take a look at the manpage",
        -:  248:	    "Need more speed? Try the light mode (Alt-y)",
        -:  249:	    "The Selection Box is shared among different instances of CliFM",
        -:  250:	    "Select files here and there with the 's' command",
        -:  251:	    "Use wildcards and regular expressions with the 's' command: "
        -:  252:	    "'s *.c' or 's .*\\.c$'",
        -:  253:	    "ELN's and the 'sel' keyword work for shell commands as well: "
        -:  254:	    "'file 1 sel'",
        -:  255:	    "Press TAB to automatically expand an ELN: 's 2' -> TAB -> "
        -:  256:	    "'s FILENAME'",
        -:  257:	    "Easily copy everything in CWD into another directory: 's * "
        -:  258:	    "&& c sel ELN/DIR'",
        -:  259:	    "Use ranges (ELN-ELN) to easily move multiple files: 'm 3-12 "
        -:  260:	    "ELN/DIR'",
        -:  261:	    "Trash files with a simple 't ELN'",
        -:  262:	    "Get mime information for a file: 'mm info ELN'",
        -:  263:	    "If too many files are listed, try enabling the pager ('pg on')",
        -:  264:	    "Once in the pager, go backwards pressing the keyboard shortcut "
        -:  265:	    "provided by your terminal emulator",
        -:  266:	    "Once in the pager, press 'q' to stop it",
        -:  267:	    "Press 'Alt-l' to switch to long view mode",
        -:  268:	    "Search for files using the slash command: '/*.png'",
        -:  269:	    "The search function allows regular expressions: '/^c'",
        -:  270:	    "Add a new bookmark by just entering 'bm a ELN/FILE'",
        -:  271:	    "Use c, l, m, md, and r instead of cp, ln, mv, mkdir, and rm",
        -:  272:	    "Access a remote file system using the 'net' command",
        -:  273:	    "Manage default associated applications with the 'mime' command",
        -:  274:	    "Go back and forth in the directory history with 'Alt-j' and 'Alt-k' "
        -:  275:	    "or Shift-Left and Shift-Right",
        -:  276:	    "Open a new instance of CliFM with the 'x' command: 'x ELN/DIR'",
        -:  277:	    "Send a command directly to the system shell with ';CMD'",
        -:  278:	    "Run the last executed command by just running '!!'",
        -:  279:	    "Import aliases from file using 'alias import FILE'",
        -:  280:	    "List available aliases by running 'alias'",
        -:  281:	    "Create aliases to easily run your preferred commands",
        -:  282:	    "Open and edit the configuration file with 'edit'",
        -:  283:	    "Find a description for each CliFM command by running 'cmd'",
        -:  284:	    "Print the currently used color codes list by entering 'cc'",
        -:  285:	    "Press 'Alt-i' or 'Alt-.' to toggle hidden files on/off",
        -:  286:	    "List mountpoints by pressing 'Alt-m'",
        -:  287:	    "Disallow the use of shell commands with the -x option: 'clifm -x'",
        -:  288:	    "Go to the root directory by just pressing 'Alt-r'",
        -:  289:	    "Go to the home directory by just pressing 'Alt-e'",
        -:  290:	    "Press 'F8' to open and edit current color scheme",
        -:  291:	    "Press 'F9' to open and edit the keybindings file",
        -:  292:	    "Press 'F10' to open and edit the configuration file",
        -:  293:	    "Press 'F11' to open and edit the bookmarks file",
        -:  294:	    "Set the starting path: 'clifm PATH'",
        -:  295:	    "Use the 'o' command to open files and directories: '12'",
        -:  296:	    "Bypass the resource opener specifying an application: '12 "
        -:  297:	    "leafpad'",
        -:  298:	    "Open a file and send it to the background running '24&'",
        -:  299:	    "Create a custom prompt editing the configuration file",
        -:  300:	    "Customize color codes via 'cs edit' command (F6)",
        -:  301:	    "Open the bookmarks manager by just pressing 'Alt-b'",
        -:  302:	    "Chain commands using ; and &&: 's 2 7-10; r sel'",
        -:  303:	    "Add emojis to the prompt by copying them to the Prompt line "
        -:  304:	    "in the configuration file",
        -:  305:	    "Create a new profile running 'pf add PROFILE' or 'clifm -P "
        -:  306:	    "PROFILE'",
        -:  307:	    "Switch profiles using 'pf set PROFILE'",
        -:  308:	    "Delete a profile using 'pf del PROFILE'",
        -:  309:	    "Copy selected files into CWD by just running 'v sel' or "
        -:  310:	    "pressing Ctrl-Alt-v",
        -:  311:	    "Use 'p ELN' to print file properties for ELN",
        -:  312:	    "Deselect all selected files by pressing 'Alt-d'",
        -:  313:	    "Select all files in CWD by pressing 'Alt-a'",
        -:  314:	    "Jump to the Selection Box by pressing 'Alt-s'",
        -:  315:	    "Restore trashed files using the 'u' command",
        -:  316:	    "Empty the trash bin running 't clear'",
        -:  317:	    "Press Alt-f to toggle list-folders-first on/off",
        -:  318:	    "Use the 'fc' command to disable the files counter",
        -:  319:	    "Take a look at the splash screen with the 'splash' command",
        -:  320:	    "Have some fun trying the 'bonus' command",
        -:  321:	    "Launch the default system shell in CWD using ':' or ';'",
        -:  322:	    "Use 'Alt-z' and 'Alt-x' to switch sorting methods",
        -:  323:	    "Reverse sorting order using the 'rev' option: 'st rev'",
        -:  324:	    "Compress and decompress files using the 'ac' and 'ad' "
        -:  325:	    "commands respectivelly",
        -:  326:	    "Rename multiple files at once with the bulk rename function: "
        -:  327:	    "'br *.txt'",
        -:  328:	    "Need no more tips? Disable this feature in the configuration "
        -:  329:	    "file",
        -:  330:	    "Need root privileges? Launch a new instance of CLifM as root "
        -:  331:	    "running the 'X' command",
        -:  332:	    "Create custom commands and features using the 'actions' command",
        -:  333:	    "Create a fresh configuration file by running 'edit gen'",
        -:  334:	    "Use 'ln edit' (or 'le') to edit symbolic links",
        -:  335:	    "Change default keyboard shortcuts by editing the keybindings file (F9)",
        -:  336:	    "Keep in sight previous and next visited directories enabling the "
        -:  337:	    "DirhistMap option in the configuration file",
        -:  338:	    "Leave no traces at all running in stealth mode (-S)",
        -:  339:	    "Pin a file via the 'pin' command and then use it with the "
        -:  340:	    "period keyword (,). Ex: 'pin DIR' and then 'cd ,'",
        -:  341:	    "Switch between color schemes using the 'cs' command",
        -:  342:	    "Try the 'j' command to quickly navigate through visited "
        -:  343:	    "directories",
        -:  344:	    "Switch workspaces by pressing Alt-[1-4]",
        -:  345:	    "Use the 'ws' command to list available workspaces",
        -:  346:	    "Take a look at available plugins using the 'actions' command",
        -:  347:	    "Space is not needed: enter 'p12' instead of 'p 12'",
        -:  348:	    "When searching or selecting files, use the exclamation mark "
        -:  349:	    "to reverse the meaning of a pattern",
        -:  350:	    "Enable the TrashAsRm option to prevent accidental deletions",
        -:  351:	    "Don't like ELN's? Disable them using the -e option",
        -:  352:	    "Use the 'n' command to create multiple files and/or directories",
        -:  353:	    "Customize your prompt by adding prompt commands via the 'edit' "
        -:  354:	    "command (F10)",
        -:  355:	    "Need git integration? Consult the manpage",
        -:  356:	    "Accept a given suggestion by pressing the Right arrow key",
        -:  357:	    "Accept only the first suggested word by pressing Alt-f or Alt-Right",
        -:  358:	    "Enter 'c sel' to copy selected files into the current directory",
        -:  359:	    "Take a look at available plugins via the 'actions' command",
        -:  360:	    NULL};
        -:  361:
        5:  362:	size_t tipsn = (sizeof(TIPS) / sizeof(TIPS[0])) - 1;
        -:  363:
        5:  364:	if (all) {
        5:  364-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -:  365:		size_t i;
       96:  366:		for (i = 0; i < tipsn; i++)
        1:  366-block  0
unconditional  0 taken 1
unconditional  1 taken 95
       96:  366-block  1
branch  2 taken 95
branch  3 taken 1 (fallthrough)
       95:  367:			printf("%sTIP %zu%s: %s\n", BOLD, i, df_c, TIPS[i]);
       95:  367-block  0
call    0 returned 95
        -:  368:
        1:  369:		return;
        1:  369-block  0
unconditional  0 taken 1
        -:  370:	}
        -:  371:
        4:  372:	srand((unsigned int)time(NULL));
        4:  372-block  0
call    0 returned 4
call    1 returned 4
        4:  373:	printf("%sTIP%s: %s\n", BOLD, df_c, TIPS[rand() % (int)tipsn]);
call    0 returned 4
call    1 returned 4
        -:  374:}
        -:  375:
        -:  376:/* Open DIR in a new instance of the program (using TERM, set in the config
        -:  377: * file, as terminal emulator) */
        -:  378:int
function new_instance called 3 returned 100% blocks executed 60%
        3:  379:new_instance(char *dir, int sudo)
        -:  380:{
        -:  381:#if defined(__HAIKU__)
        -:  382:	UNUSED(dir); UNUSED(sudo);
        -:  383:	fprintf(stderr, _("%s: This function is not available on Haiku\n"),
        -:  384:			PROGRAM_NAME);
        -:  385:	return EXIT_FAILURE;
        -:  386:#elif defined(__OpenBSD__)
        -:  387:	UNUSED(dir); UNUSED(sudo);
        -:  388:	fprintf(stderr, _("%s: This function is not available on OpenBSD\n"),
        -:  389:			PROGRAM_NAME);
        -:  390:	return EXIT_FAILURE;
        -:  391:#else
        3:  392:	if (!term) {
        3:  392-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  393:		fprintf(stderr, _("%s: Default terminal not set. Use the "
    %%%%%:  393-block  0
call    0 never executed
call    1 never executed
        -:  394:				"configuration file to set one\n"), PROGRAM_NAME);
    #####:  395:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  396:	}
        -:  397:
        3:  398:	if (!(flags & GUI)) {
        3:  398-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  399:		fprintf(stderr, _("%s: Function only available for graphical "
    %%%%%:  399-block  0
call    0 never executed
call    1 never executed
        -:  400:				"environments\n"), PROGRAM_NAME);
    #####:  401:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  402:	}
        -:  403:
        -:  404:	/* Get absolute path of executable name of itself */
        -:  405:#if defined(__linux__)
        3:  406:	char *self = realpath("/proc/self/exe", NULL);
        3:  406-block  0
call    0 returned 3
        -:  407:
        3:  408:	if (!self) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  409:#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
        -:  410:	const int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
        -:  411:	char *self = malloc(PATH_MAX);
        -:  412:	size_t len = PATH_MAX;
        -:  413:
        -:  414:	if (!self || sysctl(mib, 4, self, &len, NULL, 0) == -1) {
        -:  415:#endif
    #####:  416:		fprintf(stderr, "%s: %s\n", PROGRAM_NAME, strerror(errno));
    %%%%%:  416-block  0
call    0 never executed
call    1 never executed
    #####:  417:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  418:	}
        -:  419:
        3:  420:	if (!dir) {
        3:  420-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  421:		free(self);
    #####:  422:		return EXIT_FAILURE;
    %%%%%:  422-block  0
unconditional  0 never executed
        -:  423:	}
        -:  424:
        3:  425:	char *_sudo = (char *)NULL;
        3:  426:	if (sudo) {
        3:  426-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  427:		_sudo = get_sudo_path();
        1:  427-block  0
call    0 returned 1
        1:  428:		if (!_sudo) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  429:			free(self);
    #####:  430:			return EXIT_FAILURE;
    %%%%%:  430-block  0
unconditional  0 never executed
        -:  431:		}
        -:  432:	}
        -:  433:
        3:  434:	char *deq_dir = dequote_str(dir, 0);
        3:  434-block  0
call    0 returned 3
        -:  435:
        3:  436:	if (!deq_dir) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  437:		fprintf(stderr, _("%s: %s: Error dequoting file name\n"),
    %%%%%:  437-block  0
call    0 never executed
call    1 never executed
        -:  438:		    PROGRAM_NAME, dir);
    #####:  439:		free(self);
    #####:  440:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  441:	}
        -:  442:
        -:  443:	struct stat file_attrib;
        -:  444:
        3:  445:	if (stat(deq_dir, &file_attrib) == -1) {
        3:  445-block  0
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  446:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, deq_dir,
call    0 never executed
    #####:  447:		    strerror(errno));
    %%%%%:  447-block  0
call    0 never executed
    #####:  448:		free(self);
    #####:  449:		free(deq_dir);
    #####:  450:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  451:	}
        -:  452:
        3:  453:	if ((file_attrib.st_mode & S_IFMT) != S_IFDIR) {
        3:  453-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  454:		fprintf(stderr, _("%s: %s: Not a directory\n"), PROGRAM_NAME, deq_dir);
    %%%%%:  454-block  0
call    0 never executed
call    1 never executed
    #####:  455:		free(self);
    #####:  456:		free(deq_dir);
    #####:  457:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  458:	}
        -:  459:
        3:  460:	char *path_dir = (char *)NULL;
        -:  461:
        3:  462:	if (*deq_dir != '/') {
        3:  462-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  463:		path_dir = (char *)xnmalloc(strlen(ws[cur_ws].path)
    #####:  464:							+ strlen(deq_dir) + 2, sizeof(char));
    %%%%%:  464-block  0
call    0 never executed
    #####:  465:		sprintf(path_dir, "%s/%s", ws[cur_ws].path, deq_dir);
    #####:  466:		free(deq_dir);
unconditional  0 never executed
        -:  467:	} else {
        3:  468:		path_dir = deq_dir;
        3:  468-block  0
unconditional  0 taken 3
        -:  469:	}
        -:  470:
        3:  471:	char **tmp_term = (char **)NULL,
        3:  472:		 **tmp_cmd = (char **)NULL;
        -:  473:
        3:  474:	if (strcntchr(term, ' ') != -1) {
        3:  474-block  0
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        3:  475:		tmp_term = get_substr(term, ' ');
        3:  475-block  0
call    0 returned 3
        -:  476:
        3:  477:		if (tmp_term) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:  478:			int i;
        9:  479:			for (i = 0; tmp_term[i]; i++);
        3:  479-block  0
unconditional  0 taken 3
        6:  479-block  1
unconditional  1 taken 6
        9:  479-block  2
branch  2 taken 6
branch  3 taken 3 (fallthrough)
        -:  480:
        3:  481:			int num = i;
        3:  482:			tmp_cmd = (char **)xrealloc(tmp_cmd, ((size_t)i + (sudo ? 4 : 3))
        3:  482-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  482-block  1
unconditional  2 taken 1
        2:  482-block  2
unconditional  3 taken 2
        3:  482-block  3
call    4 returned 3
        -:  483:													* sizeof(char *));
        9:  484:			for (i = 0; tmp_term[i]; i++) {
unconditional  0 taken 3
        9:  484-block  0
branch  1 taken 6
branch  2 taken 3 (fallthrough)
        6:  485:				tmp_cmd[i] = savestring(tmp_term[i], strlen(tmp_term[i]));
        6:  485-block  0
call    0 returned 6
        6:  486:				free(tmp_term[i]);
unconditional  0 taken 6
        -:  487:			}
        3:  488:			free(tmp_term);
        -:  489:
        3:  490:			i = num - 1;
        3:  491:			int plus = 1;
        -:  492:
        3:  493:			if (sudo) {
        3:  493-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  494:				tmp_cmd[i + plus] = (char *)xnmalloc(strlen(self) + 1,
        1:  494-block  0
call    0 returned 1
        -:  495:				    sizeof(char));
        1:  496:				strcpy(tmp_cmd[i + plus], _sudo);
        1:  497:				plus++;
unconditional  0 taken 1
        -:  498:			}
        -:  499:
        3:  500:			tmp_cmd[i + plus] = (char *)xnmalloc(strlen(self) + 1, sizeof(char));
        3:  500-block  0
call    0 returned 3
        3:  501:			strcpy(tmp_cmd[i + plus++], self);
        3:  502:			tmp_cmd[i + plus] = (char *)xnmalloc(strlen(path_dir) + 1, sizeof(char));
call    0 returned 3
        3:  503:			strcpy(tmp_cmd[i + plus++], path_dir);
        3:  504:			tmp_cmd[i + plus] = (char *)NULL;
unconditional  0 taken 3
        -:  505:		}
        -:  506:	}
        -:  507:
        3:  508:	int ret = -1;
        -:  509:
        3:  510:	if (tmp_cmd) {
        3:  510-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  511:		ret = launch_execve(tmp_cmd, BACKGROUND, E_NOFLAG);
        3:  511-block  0
call    0 returned 3
        -:  512:		size_t i;
       16:  513:		for (i = 0; tmp_cmd[i]; i++)
unconditional  0 taken 3
       16:  513-block  0
branch  1 taken 13
branch  2 taken 3 (fallthrough)
       13:  514:			free(tmp_cmd[i]);
       13:  514-block  0
unconditional  0 taken 13
        3:  515:		free(tmp_cmd);
        3:  515-block  0
unconditional  0 taken 3
        -:  516:	} else {
    #####:  517:		fprintf(stderr, _("%s: No option specified for '%s'\n"
call    0 never executed
        -:  518:				"Trying '%s -e %s %s'\n"), PROGRAM_NAME, term,
    #####:  519:				term, self, ws[cur_ws].path);
    %%%%%:  519-block  0
call    0 never executed
    #####:  520:		if (sudo) {
branch  0 never executed
branch  1 never executed
    #####:  521:			char *cmd[] = {term, "-e", _sudo, self, path_dir, NULL};
    #####:  522:			ret = launch_execve(cmd, BACKGROUND, E_NOFLAG);
    %%%%%:  522-block  0
call    0 never executed
        -:  523:		} else {
    #####:  524:			char *cmd[] = {term, "-e", self, path_dir, NULL};
    #####:  525:			ret = launch_execve(cmd, BACKGROUND, E_NOFLAG);
    %%%%%:  525-block  0
call    0 never executed
        -:  526:		}
        -:  527:	}
        -:  528:
        3:  529:	free(_sudo);
        3:  530:	free(path_dir);
        3:  531:	free(self);
        -:  532:
        3:  533:	if (ret != EXIT_SUCCESS)
        3:  533-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  534:		fprintf(stderr, _("%s: Error lauching new instance\n"), PROGRAM_NAME);
    %%%%%:  534-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  535:
        3:  536:	return ret;
        3:  536-block  0
unconditional  0 taken 3
        -:  537:#endif /* !__HAIKU__ */
        -:  538:// cppcheck-suppress syntaxError
        -:  539:}
        -:  540:
        -:  541:int
function alias_import called 0 returned 0% blocks executed 0%
    #####:  542:alias_import(char *file)
        -:  543:{
    #####:  544:	if (xargs.stealth_mode == 1) {
    %%%%%:  544-block  0
branch  0 never executed
branch  1 never executed
    #####:  545:		printf("%s: The alias function is disabled in stealth mode\n",
    %%%%%:  545-block  0
call    0 never executed
        -:  546:				PROGRAM_NAME);
    #####:  547:		return EXIT_SUCCESS;
unconditional  0 never executed
        -:  548:	}
        -:  549:
    #####:  550:	if (!file)
    %%%%%:  550-block  0
branch  0 never executed
branch  1 never executed
    #####:  551:		return EXIT_FAILURE;
    %%%%%:  551-block  0
unconditional  0 never executed
        -:  552:
    #####:  553:	char rfile[PATH_MAX] = "";
    #####:  554:	rfile[0] = '\0';
        -:  555:
        -:  556:	/*  if (*file == '~' && *(file + 1) == '/') { */
        -:  557:
    #####:  558:	if (*file == '~') {
    %%%%%:  558-block  0
branch  0 never executed
branch  1 never executed
    #####:  559:		char *file_exp = tilde_expand(file);
    %%%%%:  559-block  0
call    0 never executed
    #####:  560:		if (!file_exp) {
branch  0 never executed
branch  1 never executed
    #####:  561:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, file, strerror(errno));
    %%%%%:  561-block  0
call    0 never executed
call    1 never executed
    #####:  562:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  563:		}
        -:  564:
    #####:  565:		if (realpath(file_exp, rfile) == NULL) {
    %%%%%:  565-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  566:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, file_exp,
call    0 never executed
    #####:  567:					strerror(errno));
    %%%%%:  567-block  0
call    0 never executed
    #####:  568:			free(file_exp);
    #####:  569:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  570:		}
    #####:  571:		free(file_exp);
    %%%%%:  571-block  0
unconditional  0 never executed
        -:  572:	} else {
    #####:  573:		if (realpath(file, rfile) == NULL) {
    %%%%%:  573-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  574:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, file, strerror(errno));
    %%%%%:  574-block  0
call    0 never executed
call    1 never executed
    #####:  575:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  576:		}
        -:  577:	}
        -:  578:
    #####:  579:	if (rfile[0] == '\0') {
    %%%%%:  579-block  0
branch  0 never executed
branch  1 never executed
    #####:  580:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, file, strerror(errno));
    %%%%%:  580-block  0
call    0 never executed
call    1 never executed
    #####:  581:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  582:	}
        -:  583:
        -:  584:	/* Open the file to import aliases from */
        -:  585:	int fd;
    #####:  586:	FILE *fp = open_fstream_r(rfile, &fd);
    %%%%%:  586-block  0
call    0 never executed
    #####:  587:	if (!fp) {
branch  0 never executed
branch  1 never executed
    #####:  588:		fprintf(stderr, "b%s: '%s': %s\n", PROGRAM_NAME, rfile, strerror(errno));
    %%%%%:  588-block  0
call    0 never executed
call    1 never executed
    #####:  589:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  590:	}
        -:  591:
        -:  592:	/* Open CliFM's config file as well */
    #####:  593:	FILE *config_fp = fopen(config_file, "a");
    %%%%%:  593-block  0
call    0 never executed
    #####:  594:	if (!config_fp) {
branch  0 never executed
branch  1 never executed
    #####:  595:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, config_file,
call    0 never executed
    #####:  596:		    strerror(errno));
    %%%%%:  596-block  0
call    0 never executed
    #####:  597:		close_fstream(fp, fd);
call    0 never executed
    #####:  598:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  599:	}
        -:  600:
    #####:  601:	size_t line_size = 0, i;
    #####:  602:	char *line = (char *)NULL;
    #####:  603:	size_t alias_found = 0, alias_imported = 0;
    #####:  604:	int first = 1;
        -:  605:
    #####:  606:	while (getline(&line, &line_size, fp) > 0) {
    %%%%%:  606-block  0
unconditional  0 never executed
    %%%%%:  606-block  1
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  607:		if (*line == 'a' && strncmp(line, "alias ", 6) == 0) {
    %%%%%:  607-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  607-block  1
branch  2 never executed
branch  3 never executed
    #####:  608:			alias_found++;
        -:  609:
        -:  610:			/* If alias name conflicts with some internal command,
        -:  611:			 * skip it */
    #####:  612:			char *alias_name = strbtw(line, ' ', '=');
    %%%%%:  612-block  0
call    0 never executed
    #####:  613:			if (!alias_name)
branch  0 never executed
branch  1 never executed
    #####:  614:				continue;
    %%%%%:  614-block  0
unconditional  0 never executed
        -:  615:
    #####:  616:			if (is_internal_c(alias_name)) {
    %%%%%:  616-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  617:				fprintf(stderr, _("%s: Alias conflicts with "
    %%%%%:  617-block  0
call    0 never executed
call    1 never executed
        -:  618:						"internal command\n"), alias_name);
    #####:  619:				free(alias_name);
    #####:  620:				continue;
unconditional  0 never executed
        -:  621:			}
        -:  622:
    #####:  623:			char *p = line + 6; /* p points now to the beginning of the
        -:  624:			alias name (because "alias " == 6) */
        -:  625:
        -:  626:			/* Only accept single quoted aliases commands */
    #####:  627:			char *tmp = strchr(p, '=');
    #####:  628:			if (!tmp)
    %%%%%:  628-block  0
branch  0 never executed
branch  1 never executed
    #####:  629:				continue;
    %%%%%:  629-block  0
unconditional  0 never executed
    #####:  630:			if (*(++tmp) != '\'') {
    %%%%%:  630-block  0
branch  0 never executed
branch  1 never executed
    #####:  631:				free(alias_name);
    #####:  632:				continue;
    %%%%%:  632-block  0
unconditional  0 never executed
        -:  633:			}
        -:  634:
        -:  635:			/* If alias already exists, skip it too */
    #####:  636:			int exists = 0;
        -:  637:
    #####:  638:			for (i = 0; i < aliases_n; i++) {
    %%%%%:  638-block  0
unconditional  0 never executed
    %%%%%:  638-block  1
unconditional  1 never executed
    %%%%%:  638-block  2
branch  2 never executed
branch  3 never executed
    #####:  639:				int alias_len = strcntchr(aliases[i], '=');
    %%%%%:  639-block  0
call    0 never executed
    #####:  640:				if (alias_len != -1 && strncmp(aliases[i], p,
branch  0 never executed
branch  1 never executed
    #####:  641:								(size_t)alias_len + 1) == 0) {
    %%%%%:  641-block  0
branch  0 never executed
branch  1 never executed
    #####:  642:					exists = 1;
    #####:  643:					break;
    %%%%%:  643-block  0
unconditional  0 never executed
        -:  644:				}
        -:  645:			}
        -:  646:
    #####:  647:			if (!exists) {
    %%%%%:  647-block  0
branch  0 never executed
branch  1 never executed
    #####:  648:				if (first) {
    %%%%%:  648-block  0
branch  0 never executed
branch  1 never executed
    #####:  649:					first = 0;
    #####:  650:					fputs("\n\n", config_fp);
    %%%%%:  650-block  0
call    0 never executed
unconditional  1 never executed
        -:  651:				}
        -:  652:
    #####:  653:				alias_imported++;
        -:  654:
        -:  655:				/* Write the new alias into CLiFM config file */
    #####:  656:				fputs(line, config_fp);
    %%%%%:  656-block  0
call    0 never executed
unconditional  1 never executed
        -:  657:			} else {
    #####:  658:				fprintf(stderr, _("%s: Alias already exists\n"),
    %%%%%:  658-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  659:				    alias_name);
        -:  660:			}
        -:  661:
    #####:  662:			free(alias_name);
    %%%%%:  662-block  0
unconditional  0 never executed
        -:  663:		}
        -:  664:	}
        -:  665:
    #####:  666:	free(line);
    #####:  667:	close_fstream(fp, fd);
    %%%%%:  667-block  0
call    0 never executed
    #####:  668:	fclose(config_fp);
call    0 never executed
        -:  669:
        -:  670:	/* No alias was found in FILE */
    #####:  671:	if (alias_found == 0) {
branch  0 never executed
branch  1 never executed
    #####:  672:		fprintf(stderr, _("%s: %s: No alias found\n"), PROGRAM_NAME,
    %%%%%:  672-block  0
call    0 never executed
call    1 never executed
        -:  673:		    rfile);
    #####:  674:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  675:	}
        -:  676:
        -:  677:	/* Aliases were found in FILE, but none was imported (either because
        -:  678:	 * they conflicted with internal commands or the alias already
        -:  679:	 * existed) */
    #####:  680:	else if (alias_imported == 0) {
    %%%%%:  680-block  0
branch  0 never executed
branch  1 never executed
    #####:  681:		fprintf(stderr, _("%s: No alias imported\n"), PROGRAM_NAME);
    %%%%%:  681-block  0
call    0 never executed
call    1 never executed
    #####:  682:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  683:	}
        -:  684:
        -:  685:	/* If some alias was found and imported, print the corresponding
        -:  686:	 * message and update the aliases array */
    #####:  687:	if (alias_imported > 1) {
    %%%%%:  687-block  0
branch  0 never executed
branch  1 never executed
    #####:  688:		printf(_("%s: %zu aliases were successfully imported\n"),
    %%%%%:  688-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  689:				PROGRAM_NAME, alias_imported);
        -:  690:	} else {
    #####:  691:		printf(_("%s: 1 alias was successfully imported\n"), PROGRAM_NAME);
    %%%%%:  691-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  692:	}
        -:  693:
        -:  694:	/* Add new aliases to the internal list of aliases */
    #####:  695:	get_aliases();
    %%%%%:  695-block  0
call    0 never executed
        -:  696:
        -:  697:	/* Add new aliases to the commands list for TAB completion */
    #####:  698:	if (bin_commands) {
branch  0 never executed
branch  1 never executed
    #####:  699:		for (i = 0; bin_commands[i]; i++)
    %%%%%:  699-block  0
unconditional  0 never executed
    %%%%%:  699-block  1
branch  1 never executed
branch  2 never executed
    #####:  700:			free(bin_commands[i]);
    %%%%%:  700-block  0
unconditional  0 never executed
    #####:  701:		free(bin_commands);
    #####:  702:		bin_commands = (char **)NULL;
    %%%%%:  702-block  0
unconditional  0 never executed
        -:  703:	}
        -:  704:
    #####:  705:	get_path_programs();
    %%%%%:  705-block  0
call    0 never executed
    #####:  706:	return EXIT_SUCCESS;
unconditional  0 never executed
        -:  707:}
        -:  708:
        -:  709:/* Store last visited directory for the restore last path and the
        -:  710: * cd on quit functions */
        -:  711:void
function save_last_path called 8 returned 100% blocks executed 76%
        8:  712:save_last_path(void)
        -:  713:{
        8:  714:	if (!config_ok || !config_dir)
        8:  714-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  714-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 8
    #####:  715:		return;
    %%%%%:  715-block  0
unconditional  0 never executed
        -:  716:
        8:  717:	char *last_dir = (char *)xnmalloc(strlen(config_dir) + 7, sizeof(char));
        8:  717-block  0
call    0 returned 8
        8:  718:	sprintf(last_dir, "%s/.last", config_dir);
        -:  719:
        -:  720:	FILE *last_fp;
        8:  721:	last_fp = fopen(last_dir, "w");
call    0 returned 8
        8:  722:	if (!last_fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  723:		fprintf(stderr, _("%s: Error saving last visited "
    %%%%%:  723-block  0
call    0 never executed
call    1 never executed
        -:  724:				  "directory\n"),
        -:  725:		    PROGRAM_NAME);
    #####:  726:		free(last_dir);
    #####:  727:		return;
unconditional  0 never executed
        -:  728:	}
        -:  729:
        -:  730:	size_t i;
       72:  731:	for (i = 0; i < MAX_WS; i++) {
        8:  731-block  0
unconditional  0 taken 8
       64:  731-block  1
unconditional  1 taken 64
       72:  731-block  2
branch  2 taken 64
branch  3 taken 8 (fallthrough)
       64:  732:		if (ws[i].path) {
       64:  732-block  0
branch  0 taken 29 (fallthrough)
branch  1 taken 35
        -:  733:			/* Mark current workspace with an asterisk. It will
        -:  734:			 * be read at startup by get_last_path */
       29:  735:			if ((size_t)cur_ws == i)
       29:  735-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 21
        8:  736:				fprintf(last_fp, "*%zu:%s\n", i, ws[i].path);
        8:  736-block  0
call    0 returned 8
unconditional  1 taken 8
        -:  737:			else
       21:  738:				fprintf(last_fp, "%zu:%s\n", i, ws[i].path);
       21:  738-block  0
call    0 returned 21
unconditional  1 taken 21
        -:  739:		}
        -:  740:	}
        -:  741:
        8:  742:	fclose(last_fp);
        8:  742-block  0
call    0 returned 8
        -:  743:
        8:  744:	char *last_dir_tmp = xnmalloc(strlen(config_dir_gral) + 7, sizeof(char *));
call    0 returned 8
        8:  745:	sprintf(last_dir_tmp, "%s/.last", config_dir_gral);
        -:  746:
        8:  747:	if (cd_on_quit) {
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  748:		char *cmd[] = {"cp", "-p", last_dir, last_dir_tmp,
        -:  749:		    NULL};
        -:  750:
    #####:  751:		launch_execve(cmd, FOREGROUND, E_NOFLAG);
    %%%%%:  751-block  0
call    0 never executed
        -:  752:	} else {
        -:  753:		/* If not cd on quit, remove the file */
        8:  754:		char *cmd[] = {"rm", "-f", last_dir_tmp, NULL};
        8:  755:		launch_execve(cmd, FOREGROUND, E_NOFLAG);
        8:  755-block  0
call    0 returned 8
        -:  756:	}
        -:  757:
        8:  758:	free(last_dir_tmp);
        8:  759:	free(last_dir);
        8:  760:	return;
        8:  760-block  0
unconditional  0 taken 8
        -:  761:}
        -:  762:
        -:  763:char *
function parse_usrvar_value called 0 returned 0% blocks executed 0%
    #####:  764:parse_usrvar_value(const char *str, const char c)
        -:  765:{
    #####:  766:	if (c == '\0' || !str)
    %%%%%:  766-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  766-block  1
branch  2 never executed
branch  3 never executed
    #####:  767:		return (char *)NULL;
    %%%%%:  767-block  0
unconditional  0 never executed
        -:  768:
        -:  769:	/* Get whatever comes after c */
    #####:  770:	char *tmp = (char *)NULL;
    #####:  771:	tmp = strchr(str, c);
        -:  772:
        -:  773:	/* If no C or there's nothing after C */
    #####:  774:	if (!tmp || !*(++tmp))
    %%%%%:  774-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  774-block  1
branch  2 never executed
branch  3 never executed
    #####:  775:		return (char *)NULL;
    %%%%%:  775-block  0
unconditional  0 never executed
        -:  776:
        -:  777:	/* Remove leading quotes */
    #####:  778:	if (*tmp == '"' || *tmp == '\'')
    %%%%%:  778-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  778-block  1
branch  2 never executed
branch  3 never executed
    #####:  779:		tmp++;
    %%%%%:  779-block  0
unconditional  0 never executed
        -:  780:
        -:  781:	/* Remove trailing spaces, tabs, new line chars, and quotes */
    #####:  782:	size_t tmp_len = strlen(tmp),
        -:  783:		   i;
        -:  784:
    #####:  785:	for (i = tmp_len - 1; tmp[i] && i > 0; i--) {
    %%%%%:  785-block  0
unconditional  0 never executed
    %%%%%:  785-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  785-block  2
branch  3 never executed
branch  4 never executed
    #####:  786:		if (tmp[i] != ' ' && tmp[i] != '\t' && tmp[i] != '"' && tmp[i] != '\''
    %%%%%:  786-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  786-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  786-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  786-block  3
branch  6 never executed
branch  7 never executed
    #####:  787:		&& tmp[i] != '\n')
    %%%%%:  787-block  0
branch  0 never executed
branch  1 never executed
        -:  788:			break;
        -:  789:		else
    #####:  790:			tmp[i] = '\0';
    %%%%%:  790-block  0
unconditional  0 never executed
        -:  791:	}
        -:  792:
    #####:  793:	if (!*tmp)
    %%%%%:  793-block  0
branch  0 never executed
branch  1 never executed
    #####:  794:		return (char *)NULL;
    %%%%%:  794-block  0
unconditional  0 never executed
        -:  795:
        -:  796:	/* Copy the result string into a buffer and return it */
    #####:  797:	char *buf = (char *)NULL;
    #####:  798:	buf = savestring(tmp, strlen(tmp));
    %%%%%:  798-block  0
call    0 never executed
    #####:  799:	tmp = (char *)NULL;
        -:  800:
    #####:  801:	if (buf)
branch  0 never executed
branch  1 never executed
    #####:  802:		return buf;
    %%%%%:  802-block  0
unconditional  0 never executed
    #####:  803:	return (char *)NULL;
    %%%%%:  803-block  0
unconditional  0 never executed
        -:  804:}
        -:  805:
        -:  806:int
function create_usr_var called 0 returned 0% blocks executed 0%
    #####:  807:create_usr_var(char *str)
        -:  808:{
    #####:  809:	char *name = strbfr(str, '=');
    %%%%%:  809-block  0
call    0 never executed
    #####:  810:	char *value = parse_usrvar_value(str, '=');
call    0 never executed
        -:  811:
    #####:  812:	if (!name) {
branch  0 never executed
branch  1 never executed
    #####:  813:		if (value)
    %%%%%:  813-block  0
branch  0 never executed
branch  1 never executed
    #####:  814:			free(value);
    %%%%%:  814-block  0
unconditional  0 never executed
    #####:  815:		fprintf(stderr, _("%s: Error getting variable name\n"),
    %%%%%:  815-block  0
call    0 never executed
call    1 never executed
        -:  816:		    PROGRAM_NAME);
    #####:  817:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  818:	}
        -:  819:
    #####:  820:	if (!value) {
    %%%%%:  820-block  0
branch  0 never executed
branch  1 never executed
    #####:  821:		free(name);
    #####:  822:		fprintf(stderr, _("%s: Error getting variable value\n"),
    %%%%%:  822-block  0
call    0 never executed
call    1 never executed
        -:  823:		    PROGRAM_NAME);
    #####:  824:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  825:	}
        -:  826:
    #####:  827:	usr_var = xrealloc(usr_var, (size_t)(usrvar_n + 1) * sizeof(struct usrvar_t));
    %%%%%:  827-block  0
call    0 never executed
    #####:  828:	usr_var[usrvar_n].name = savestring(name, strlen(name));
call    0 never executed
    #####:  829:	usr_var[usrvar_n++].value = savestring(value, strlen(value));
call    0 never executed
        -:  830:
    #####:  831:	free(name);
    #####:  832:	free(value);
    #####:  833:	return EXIT_SUCCESS;
unconditional  0 never executed
        -:  834:}
        -:  835:
        -:  836:/* Custom POSIX implementation of GNU asprintf() modified to log program
        -:  837: * messages. MSG_TYPE is one of: 'e', 'w', 'n', or zero (meaning this
        -:  838: * latter that no message mark (E, W, or N) will be added to the prompt).
        -:  839: * PROMPT tells whether to print the message immediately before the
        -:  840: * prompt or rather in place. Based on littlstar's xasprintf
        -:  841: * implementation:
        -:  842: * https://github.com/littlstar/asprintf.c/blob/master/asprintf.c*/
        -:  843:__attribute__((__format__(__printf__, 3, 0)))
        -:  844:/* We use __attribute__ here to silence clang warning: "format string is
        -:  845: * not a string literal" */
        -:  846:int
function _err called 3 returned 100% blocks executed 72%
        3:  847:_err(int msg_type, int prompt, const char *format, ...)
        -:  848:{
        -:  849:	va_list arglist, tmp_list;
        3:  850:	int size = 0;
        -:  851:
        3:  852:	va_start(arglist, format);
        3:  853:	va_copy(tmp_list, arglist);
        3:  854:	size = vsnprintf((char *)NULL, 0, format, tmp_list);
        3:  855:	va_end(tmp_list);
        -:  856:
        3:  857:	if (size < 0) {
        3:  857-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  858:		va_end(arglist);
    #####:  859:		return EXIT_FAILURE;
    %%%%%:  859-block  0
unconditional  0 never executed
        -:  860:	}
        -:  861:
        3:  862:	char *buf = (char *)xcalloc((size_t)size + 1, sizeof(char));
        3:  862-block  0
call    0 returned 3
        -:  863:
        3:  864:	vsprintf(buf, format, arglist);
        3:  865:	va_end(arglist);
        -:  866:
        -:  867:	/* If the new message is the same as the last message, skip it */
        3:  868:	if (msgs_n && strcmp(messages[msgs_n - 1], buf) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  868-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  869:		free(buf);
    #####:  870:		return EXIT_SUCCESS;
    %%%%%:  870-block  0
unconditional  0 never executed
        -:  871:	}
        -:  872:
        3:  873:	if (buf) {
        3:  873-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  874:		if (msg_type) {
        3:  874-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  875:			switch (msg_type) {
        2:  875-block  0
branch  0 taken 0
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0
    #####:  876:			case 'e': pmsg = ERROR; break;
    %%%%%:  876-block  0
unconditional  0 never executed
        1:  877:			case 'w': pmsg = WARNING; break;
        1:  877-block  0
unconditional  0 taken 1
        1:  878:			case 'n': pmsg = NOTICE; break;
        1:  878-block  0
unconditional  0 taken 1
    #####:  879:			default: pmsg = NOMSG;
    %%%%%:  879-block  0
unconditional  0 never executed
        -:  880:			}
        -:  881:		}
        -:  882:
        3:  883:		log_msg(buf, (prompt) ? PRINT_PROMPT : NOPRINT_PROMPT);
        3:  883-block  0
call    0 returned 3
        3:  884:		free(buf);
        3:  885:		return EXIT_SUCCESS;
unconditional  0 taken 3
        -:  886:	}
        -:  887:
    #####:  888:	return EXIT_FAILURE;
    %%%%%:  888-block  0
unconditional  0 never executed
        -:  889:}
        -:  890:
        -:  891:/* Set STR as the program current shell */
        -:  892:int
function set_shell called 2 returned 100% blocks executed 70%
        2:  893:set_shell(char *str)
        -:  894:{
        2:  895:	if (!str || !*str)
        2:  895-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  895-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  896:		return EXIT_FAILURE;
    %%%%%:  896-block  0
unconditional  0 never executed
        -:  897:
        -:  898:	/* IF no slash in STR, check PATH env variable for a file named STR
        -:  899:	 * and get its full path*/
        2:  900:	char *full_path = (char *)NULL;
        -:  901:
        2:  902:	if (strcntchr(str, '/') == -1)
        2:  902-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  903:		full_path = get_cmd_path(str);
    %%%%%:  903-block  0
call    0 never executed
unconditional  1 never executed
        -:  904:
        2:  905:	char *tmp = (char *)NULL;
        -:  906:
        2:  907:	if (full_path)
        2:  907-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  908:		tmp = full_path;
    %%%%%:  908-block  0
unconditional  0 never executed
        -:  909:	else
        2:  910:		tmp = str;
        2:  910-block  0
unconditional  0 taken 2
        -:  911:
        2:  912:	if (access(tmp, X_OK) == -1) {
        2:  912-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  913:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, tmp, strerror(errno));
    %%%%%:  913-block  0
call    0 never executed
call    1 never executed
    #####:  914:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  915:	}
        -:  916:
        2:  917:	if (user.shell)
        2:  917-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  918:		free(user.shell);
        2:  918-block  0
unconditional  0 taken 2
        -:  919:
        2:  920:	user.shell = savestring(tmp, strlen(tmp));
        2:  920-block  0
call    0 returned 2
        2:  921:	printf(_("Successfully set '%s' as %s default shell\n"), user.shell,
call    0 returned 2
call    1 returned 2
        -:  922:	    PROGRAM_NAME);
        -:  923:
        2:  924:	if (full_path)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  925:		free(full_path);
    %%%%%:  925-block  0
unconditional  0 never executed
        2:  926:	return EXIT_SUCCESS;
        2:  926-block  0
unconditional  0 taken 2
        -:  927:}
        -:  928:
        -:  929:/* List available mountpoints and chdir into one of them */
        -:  930:int
function list_mountpoints called 1 returned 100% blocks executed 77%
        1:  931:list_mountpoints(void)
        -:  932:{
        -:  933:#if defined(__HAIKU__)
        -:  934:	fprintf(stderr, "%s: Mountpoints: This feature is not available on Haiku\n",
        -:  935:			PROGRAM_NAME);
        -:  936:	return EXIT_FAILURE;
        -:  937:#endif
        -:  938:
        -:  939:#if defined(__linux__)
        1:  940:	FILE *mp_fp = fopen("/proc/mounts", "r");
        1:  940-block  0
call    0 returned 1
        1:  941:	if (!mp_fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  942:		fprintf(stderr, "%s: mp: fopen: /proc/mounts: %s\n",
call    0 never executed
    #####:  943:				PROGRAM_NAME, strerror(errno));
    %%%%%:  943-block  0
call    0 never executed
    #####:  944:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  945:	}
        -:  946:#endif
        -:  947:
        1:  948:	printf(_("%sMountpoints%s\n\n"), BOLD, df_c);
        1:  948-block  0
call    0 returned 1
call    1 returned 1
        -:  949:
        1:  950:	char **mountpoints = (char **)NULL;
        1:  951:	size_t mp_n = 0;
        1:  952:	int i, exit_status = EXIT_SUCCESS;
        -:  953:
        -:  954:#if defined(__linux__)
        1:  955:	size_t line_size = 0;
        1:  956:	char *line = (char *)NULL;
        -:  957:
       37:  958:	while (getline(&line, &line_size, mp_fp) > 0) {
unconditional  0 taken 1
       37:  958-block  0
call    1 returned 37
branch  2 taken 36
branch  3 taken 1 (fallthrough)
        -:  959:		/* Do not list all mountpoints, but only those corresponding
        -:  960:		 * to a block device (/dev) */
       36:  961:		if (strncmp(line, "/dev/", 5) == 0) {
       36:  961-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 31
        5:  962:			char *str = (char *)NULL;
        5:  963:			size_t counter = 0;
        -:  964:
        -:  965:			/* use strtok() to split LINE into tokens using space as
        -:  966:			 * IFS */
        5:  967:			str = strtok(line, " ");
        5:  967-block  0
call    0 returned 5
        5:  968:			size_t dev_len = strlen(str);
        -:  969:
        5:  970:			char *device = savestring(str, dev_len);
call    0 returned 5
        -:  971:			/* Print only the first two fileds of each /proc/mounts
        -:  972:			 * line */
       15:  973:			while (str && counter < 2) {
unconditional  0 taken 5
       15:  973-block  0
branch  1 taken 15 (fallthrough)
branch  2 taken 0
       15:  973-block  1
branch  3 taken 10
branch  4 taken 5 (fallthrough)
       10:  974:				if (counter == 1) { /* 1 == second field */
       10:  974-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 5
       5*:  975:					printf("%s%zu%s %s%s%s (%s)\n", el_c, mp_n + 1,
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:  975-block  0
unconditional  2 taken 5
    %%%%%:  975-block  1
unconditional  3 never executed
        5:  975-block  2
call    4 returned 5
        5:  976:					    df_c, (access(str, R_OK | X_OK) == 0) ? di_c : nd_c,
        5:  976-block  0
call    0 returned 5
        -:  977:					    str, df_c, device);
        -:  978:					/* Store the second field (mountpoint) into an
        -:  979:					 * array */
        5:  980:					mountpoints = (char **)xrealloc(mountpoints,
        5:  981:					    (mp_n + 1) * sizeof(char *));
call    0 returned 5
        5:  982:					mountpoints[mp_n++] = savestring(str, strlen(str));
call    0 returned 5
unconditional  1 taken 5
        -:  983:				}
        -:  984:
       10:  985:				str = strtok(NULL, " ,");
       10:  985-block  0
call    0 returned 10
       10:  986:				counter++;
unconditional  0 taken 10
        -:  987:			}
        -:  988:
        5:  989:			free(device);
        5:  989-block  0
unconditional  0 taken 5
        -:  990:		}
        -:  991:	}
        -:  992:
        1:  993:	free(line);
        1:  994:	line = (char *)NULL;
        1:  995:	fclose(mp_fp);
        1:  995-block  0
call    0 returned 1
        -:  996:
        -:  997:#elif defined(__FreeBSD__) || defined(__OpenBSD__)
        -:  998:	struct statfs *fslist;
        -:  999:	mp_n = (size_t)getmntinfo(&fslist, MNT_NOWAIT);
        -: 1000:#elif defined(__NetBSD__)
        -: 1001:	struct statvfs *fslist;
        -: 1002:	mp_n = (size_t)getmntinfo(&fslist, MNT_NOWAIT);
        -: 1003:#endif
        -: 1004:
        -: 1005:	/* This should never happen: There should always be a mountpoint,
        -: 1006:	 * at least "/" */
        -: 1007:	// cppcheck-suppress knownConditionTrueFalse
        1: 1008:	if (mp_n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1009:		fputs(_("mp: There are no available mountpoints\n"), stdout);
    %%%%%: 1009-block  0
call    0 never executed
call    1 never executed
    #####: 1010:		return EXIT_SUCCESS;
unconditional  0 never executed
        -: 1011:	}
        -: 1012:#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
        -: 1013:	int j;
        -: 1014:	for (i = j = 0; i < (int)mp_n; i++) {
        -: 1015:		/* Do not list all mountpoints, but only those corresponding
        -: 1016:		 * to a block device (/dev) */
        -: 1017:		if (strncmp(fslist[i].f_mntfromname, "/dev/", 5) == 0) {
        -: 1018:			printf("%s%d%s %s%s%s (%s)\n", el_c, j + 1, df_c,
        -: 1019:			    (access(fslist[i].f_mntonname, R_OK | X_OK) == 0)
        -: 1020:			    ? di_c : nd_c, fslist[i].f_mntonname,
        -: 1021:			    df_c, fslist[i].f_mntfromname);
        -: 1022:			/* Store the mountpoint into an array */
        -: 1023:			mountpoints = (char **)xrealloc(mountpoints,
        -: 1024:			    (size_t)(j + 1) * sizeof(char *));
        -: 1025:			mountpoints[j++] = savestring(fslist[i].f_mntonname,
        -: 1026:			    strlen(fslist[i].f_mntonname));
        -: 1027:		}
        -: 1028:	}
        -: 1029:	/* Update filesystem counter as it would be used to free() the
        -: 1030:	 * mountpoints entries later (below) */
        -: 1031:	mp_n = (size_t)j;
        -: 1032:#endif
        -: 1033:
        1: 1034:	putchar('\n');
        1: 1034-block  0
call    0 returned 1
        -: 1035:	/* Ask the user and chdir into the selected mountpoint */
        1: 1036:	char *input = (char *)NULL;
        2: 1037:	while (!input)
unconditional  0 taken 1
        2: 1037-block  0
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        1: 1038:		input = rl_no_hist(_("Choose a mountpoint ('q' to quit): "));
        1: 1038-block  0
call    0 returned 1
call    1 returned 1
unconditional  2 taken 1
        -: 1039:
       1*: 1040:	if (!(*input == 'q' && *(input + 1) == '\0')) {
        1: 1040-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1040-block  1
branch  2 never executed
branch  3 never executed
        1: 1041:		int atoi_num = atoi(input);
        1: 1042:		if (atoi_num > 0 && atoi_num <= (int)mp_n) {
        1: 1042-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1042-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1043:			if (xchdir(mountpoints[atoi_num - 1], SET_TITLE) == EXIT_SUCCESS) {
        1: 1043-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 1044:				free(ws[cur_ws].path);
        2: 1045:				ws[cur_ws].path = savestring(mountpoints[atoi_num - 1],
        1: 1046:				    strlen(mountpoints[atoi_num - 1]));
        1: 1046-block  0
call    0 returned 1
        -: 1047:
        1: 1048:				if (cd_lists_on_the_fly) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1049:					free_dirlist();
        1: 1049-block  0
call    0 returned 1
        1: 1050:					if (list_dir() != EXIT_SUCCESS)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1051:						exit_status = EXIT_FAILURE;
    %%%%%: 1051-block  0
unconditional  0 never executed
        -: 1052:				}
        -: 1053:
        1: 1054:				add_to_dirhist(ws[cur_ws].path);
        1: 1054-block  0
call    0 returned 1
        1: 1055:				add_to_jumpdb(ws[cur_ws].path);
call    0 returned 1
unconditional  1 taken 1
        -: 1056:			} else {
    #####: 1057:				fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####: 1058:				    mountpoints[atoi_num - 1], strerror(errno));
    %%%%%: 1058-block  0
call    0 never executed
call    1 never executed
    #####: 1059:				exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -: 1060:			}
        -: 1061:		} else {
    #####: 1062:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####: 1063:			    mountpoints[atoi_num - 1], strerror(errno));
    %%%%%: 1063-block  0
call    0 never executed
call    1 never executed
    #####: 1064:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -: 1065:		}
        -: 1066:	}
        -: 1067:
        -: 1068:	/* Free stuff and exit */
        1: 1069:	free(input);
        -: 1070:
        1: 1071:	i = (int)mp_n;
        6: 1072:	while (--i >= 0)
        1: 1072-block  0
unconditional  0 taken 1
        6: 1072-block  1
branch  1 taken 5
branch  2 taken 1 (fallthrough)
        5: 1073:		free(mountpoints[i]);
        5: 1073-block  0
unconditional  0 taken 5
        1: 1074:	free(mountpoints);
        -: 1075:
        1: 1076:	return exit_status;
        1: 1076-block  0
unconditional  0 taken 1
        -: 1077:}
        -: 1078:
        -: 1079:/* Store pinned directory for the next session */
        -: 1080:void
function save_pinned_dir called 4 returned 100% blocks executed 83%
        4: 1081:save_pinned_dir(void)
        -: 1082:{
        4: 1083:	if (pinned_dir && config_ok) {
        4: 1083-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 1083-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 1084:
        1: 1085:		char *pin_file = (char *)xnmalloc(strlen(config_dir) + 7,
        1: 1085-block  0
call    0 returned 1
        -: 1086:		    sizeof(char));
        1: 1087:		sprintf(pin_file, "%s/.pin", config_dir);
        -: 1088:
        1: 1089:		FILE *fp = fopen(pin_file, "w");
call    0 returned 1
        1: 1090:		if (!fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1091:			fprintf(stderr, _("%s: Error storing pinned "
    %%%%%: 1091-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -: 1092:					"directory\n"), PROGRAM_NAME);
        -: 1093:		} else {
        1: 1094:			fprintf(fp, "%s", pinned_dir);
        1: 1094-block  0
call    0 returned 1
        1: 1095:			fclose(fp);
call    0 returned 1
unconditional  1 taken 1
        -: 1096:		}
        -: 1097:
        1: 1098:		free(pin_file);
        1: 1098-block  0
unconditional  0 taken 1
        -: 1099:	}
        -: 1100:
        4: 1101:	return;
        4: 1101-block  0
unconditional  0 taken 4
        -: 1102:}
        -: 1103:
        -: 1104:int
function free_remotes called 26 returned 100% blocks executed 100%
       26: 1105:free_remotes(int exit)
        -: 1106:{
       26: 1107:	if (exit)
       26: 1107-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 22
        4: 1108:		autounmount_remotes();
        4: 1108-block  0
call    0 returned 4
unconditional  1 taken 4
        -: 1109:
        -: 1110:	size_t i;
       64: 1111:	for (i = 0; i < remotes_n; i++) {
       26: 1111-block  0
unconditional  0 taken 26
       64: 1111-block  1
branch  1 taken 38
branch  2 taken 26 (fallthrough)
       38: 1112:		free(remotes[i].name);
       38: 1113:		free(remotes[i].desc);
       38: 1114:		free(remotes[i].mountpoint);
       38: 1115:		free(remotes[i].mount_cmd);
       38: 1116:		free(remotes[i].unmount_cmd);		
       38: 1116-block  0
unconditional  0 taken 38
        -: 1117:	}
       26: 1118:	free(remotes);
       26: 1119:	remotes_n = 0;
        -: 1120:
       26: 1121:	return EXIT_SUCCESS;
       26: 1121-block  0
unconditional  0 taken 26
        -: 1122:}
        -: 1123:
        -: 1124:/* This function is called by atexit() to clear whatever is there at exit
        -: 1125: * time and avoid thus memory leaks */
        -: 1126:void
function free_stuff called 4 returned 100% blocks executed 91%
        4: 1127:free_stuff(void)
        -: 1128:{
        4: 1129:	int i = 0;
        -: 1130:
        -: 1131:#ifdef LINUX_INOTIFY
        -: 1132:	/* Shutdown inotify */
        4: 1133:	if (inotify_wd >= 0)
        4: 1133-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1134:		inotify_rm_watch(inotify_fd, inotify_wd);
        4: 1134-block  0
call    0 returned 4
unconditional  1 taken 4
        4: 1135:	close(inotify_fd);
        4: 1135-block  0
call    0 returned 4
        -: 1136:#elif defined(BSD_KQUEUE)
        -: 1137:	if (event_fd >= 0)
        -: 1138:		close(event_fd);
        -: 1139:	close(kq);
        -: 1140:#endif
        -: 1141:
        4: 1142:	if (xargs.stealth_mode != 1) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1143:		save_pinned_dir();
        4: 1143-block  0
call    0 returned 4
        4: 1144:		save_jumpdb();
call    0 returned 4
unconditional  1 taken 4
        -: 1145:	}
        -: 1146:
        4: 1147:	save_dirhist();
        4: 1147-block  0
call    0 returned 4
        -: 1148:
        4: 1149:	if (restore_last_path || cd_on_quit)
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 1149-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        3: 1150:		save_last_path();
        3: 1150-block  0
call    0 returned 3
unconditional  1 taken 3
        -: 1151:
        4: 1152:	free(alt_profile);
        4: 1153:	free_bookmarks();
        4: 1153-block  0
call    0 returned 4
        4: 1154:	free(encoded_prompt);
        4: 1155:	free_dirlist();
call    0 returned 4
        4: 1156:	free(opener);
        -: 1157:
        4: 1158:	if (stdin_tmp_dir) {
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1159:		char *rm_cmd[] = {"rm", "-rd", "--", stdin_tmp_dir, NULL};
    #####: 1160:		launch_execve(rm_cmd, FOREGROUND, E_NOFLAG);
    %%%%%: 1160-block  0
call    0 never executed
    #####: 1161:		free(stdin_tmp_dir);
unconditional  0 never executed
        -: 1162:	}
        -: 1163:
        4: 1164:	if (color_schemes) {
        4: 1164-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
       65: 1165:		for (i = 0; color_schemes[i]; i++)
        4: 1165-block  0
unconditional  0 taken 4
       65: 1165-block  1
branch  1 taken 61
branch  2 taken 4 (fallthrough)
       61: 1166:			free(color_schemes[i]);
       61: 1166-block  0
unconditional  0 taken 61
        4: 1167:		free(color_schemes);
        4: 1167-block  0
unconditional  0 taken 4
        -: 1168:	}
        -: 1169:
        4: 1170:	if (jump_db) {
        4: 1170-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1171:		i = (int)jump_n;
      147: 1172:		while (--i >= 0)
        4: 1172-block  0
unconditional  0 taken 4
      147: 1172-block  1
branch  1 taken 143
branch  2 taken 4 (fallthrough)
      143: 1173:			free(jump_db[i].path);
      143: 1173-block  0
unconditional  0 taken 143
        4: 1174:		free(jump_db);
        4: 1174-block  0
unconditional  0 taken 4
        -: 1175:	}
        -: 1176:
        4: 1177:	if (pinned_dir)
        4: 1177-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 1178:		free(pinned_dir);
        1: 1178-block  0
unconditional  0 taken 1
        -: 1179:
        4: 1180:	if (filter) {
        4: 1180-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1181:		regfree(&regex_exp);
    %%%%%: 1181-block  0
call    0 never executed
    #####: 1182:		free(filter);
unconditional  0 never executed
        -: 1183:	}
        -: 1184:
        4: 1185:	if (eln_as_file_n)
        4: 1185-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1186:		free(eln_as_file);
    %%%%%: 1186-block  0
unconditional  0 never executed
        -: 1187:
        4: 1188:	if (ext_colors_n)
        4: 1188-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1189:		free(ext_colors_len);
        4: 1189-block  0
unconditional  0 taken 4
        -: 1190:
        -: 1191:
        4: 1192:	if (profile_names) {
        4: 1192-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
       20: 1193:		for (i = 0; profile_names[i]; i++)
        4: 1193-block  0
unconditional  0 taken 4
       20: 1193-block  1
branch  1 taken 16
branch  2 taken 4 (fallthrough)
       16: 1194:			free(profile_names[i]);
       16: 1194-block  0
unconditional  0 taken 16
        4: 1195:		free(profile_names);
        4: 1195-block  0
unconditional  0 taken 4
        -: 1196:	}
        -: 1197:
        4: 1198:	if (sel_n > 0) {
        4: 1198-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1199:		i = (int)sel_n;
    #####: 1200:		while (--i >= 0)
    %%%%%: 1200-block  0
unconditional  0 never executed
    %%%%%: 1200-block  1
branch  1 never executed
branch  2 never executed
    #####: 1201:			free(sel_elements[i]);
    %%%%%: 1201-block  0
unconditional  0 never executed
    #####: 1202:		free(sel_elements);
    %%%%%: 1202-block  0
unconditional  0 never executed
        -: 1203:	}
        -: 1204:
        4: 1205:	if (bin_commands) {
        4: 1205-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1206:		i = (int)path_progsn;
    14975: 1207:		while (--i >= 0)
        4: 1207-block  0
unconditional  0 taken 4
    14975: 1207-block  1
branch  1 taken 14971
branch  2 taken 4 (fallthrough)
    14971: 1208:			free(bin_commands[i]);
    14971: 1208-block  0
unconditional  0 taken 14971
        4: 1209:		free(bin_commands);
        4: 1209-block  0
unconditional  0 taken 4
        -: 1210:	}
        -: 1211:
        4: 1212:	if (paths) {
        4: 1212-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1213:		i = (int)path_n;
       28: 1214:		while (--i >= 0)
        4: 1214-block  0
unconditional  0 taken 4
       28: 1214-block  1
branch  1 taken 24
branch  2 taken 4 (fallthrough)
       24: 1215:			free(paths[i]);
       24: 1215-block  0
unconditional  0 taken 24
        4: 1216:		free(paths);
        4: 1216-block  0
unconditional  0 taken 4
        -: 1217:	}
        -: 1218:
        4: 1219:	if (cdpaths) {
        4: 1219-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 1220:		i = (int)cdpath_n;
        9: 1221:		while (--i >= 0)
        3: 1221-block  0
unconditional  0 taken 3
        9: 1221-block  1
branch  1 taken 6
branch  2 taken 3 (fallthrough)
        6: 1222:			free(cdpaths[i]);
        6: 1222-block  0
unconditional  0 taken 6
        3: 1223:		free(cdpaths);
        3: 1223-block  0
unconditional  0 taken 3
        -: 1224:	}
        -: 1225:
        4: 1226:	if (history) {
        4: 1226-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1227:		i = (int)current_hist_n;
     3146: 1228:		while (--i >= 0)
        4: 1228-block  0
unconditional  0 taken 4
     3146: 1228-block  1
branch  1 taken 3142
branch  2 taken 4 (fallthrough)
     3142: 1229:			free(history[i]);
     3142: 1229-block  0
unconditional  0 taken 3142
        4: 1230:		free(history);
        4: 1230-block  0
unconditional  0 taken 4
        -: 1231:	}
        -: 1232:
        4: 1233:	if (argv_bk) {
        4: 1233-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1234:		i = argc_bk;
       12: 1235:		while (--i >= 0)
        4: 1235-block  0
unconditional  0 taken 4
       12: 1235-block  1
branch  1 taken 8
branch  2 taken 4 (fallthrough)
        8: 1236:			free(argv_bk[i]);
        8: 1236-block  0
unconditional  0 taken 8
        4: 1237:		free(argv_bk);
        4: 1237-block  0
unconditional  0 taken 4
        -: 1238:	}
        -: 1239:
        4: 1240:	if (dirhist_total_index) {
        4: 1240-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1241:		i = (int)dirhist_total_index;
      482: 1242:		while (--i >= 0)
        4: 1242-block  0
unconditional  0 taken 4
      482: 1242-block  1
branch  1 taken 478
branch  2 taken 4 (fallthrough)
      478: 1243:			free(old_pwd[i]);
      478: 1243-block  0
unconditional  0 taken 478
        4: 1244:		free(old_pwd);
        4: 1244-block  0
unconditional  0 taken 4
        -: 1245:	}
        -: 1246:
        4: 1247:	i = (int)kbinds_n;
      211: 1248:	while (--i >= 0) {
        4: 1248-block  0
unconditional  0 taken 4
      211: 1248-block  1
branch  1 taken 207
branch  2 taken 4 (fallthrough)
      207: 1249:		free(kbinds[i].function);
      207: 1250:		free(kbinds[i].key);
      207: 1250-block  0
unconditional  0 taken 207
        -: 1251:	}
        4: 1252:	free(kbinds);
        -: 1253:
        4: 1254:	i = (int)usrvar_n;
        4: 1255:	while (--i >= 0) {
        4: 1255-block  0
unconditional  0 taken 4
        4: 1255-block  1
branch  1 taken 0
branch  2 taken 4 (fallthrough)
    #####: 1256:		free(usr_var[i].name);
    #####: 1257:		free(usr_var[i].value);
    %%%%%: 1257-block  0
unconditional  0 never executed
        -: 1258:	}
        4: 1259:	free(usr_var);
        -: 1260:
        4: 1261:	i = (int)actions_n;
       89: 1262:	while (--i >= 0) {
        4: 1262-block  0
unconditional  0 taken 4
       89: 1262-block  1
branch  1 taken 85
branch  2 taken 4 (fallthrough)
       85: 1263:		free(usr_actions[i].name);
       85: 1264:		free(usr_actions[i].value);
       85: 1264-block  0
unconditional  0 taken 85
        -: 1265:	}
        4: 1266:	free(usr_actions);
        -: 1267:
        4: 1268:	i = (int)aliases_n;
       19: 1269:	while (--i >= 0)
        4: 1269-block  0
unconditional  0 taken 4
       19: 1269-block  1
branch  1 taken 15
branch  2 taken 4 (fallthrough)
       15: 1270:		free(aliases[i]);
       15: 1270-block  0
unconditional  0 taken 15
        4: 1271:	free(aliases);
        -: 1272:
        4: 1273:	i = (int)prompt_cmds_n;
       15: 1274:	while (--i >= 0)
        4: 1274-block  0
unconditional  0 taken 4
       15: 1274-block  1
branch  1 taken 11
branch  2 taken 4 (fallthrough)
       11: 1275:		free(prompt_cmds[i]);
       11: 1275-block  0
unconditional  0 taken 11
        4: 1276:	free(prompt_cmds);
        -: 1277:
        -: 1278:/*	if (flags & FILE_CMD_OK)
        -: 1279:		free(file_cmd_path); */
        -: 1280:
        4: 1281:	if (msgs_n) {
        4: 1281-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1: 1282:		i = (int)msgs_n;
        2: 1283:		while (--i >= 0)
        1: 1283-block  0
unconditional  0 taken 1
        2: 1283-block  1
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        1: 1284:			free(messages[i]);
        1: 1284-block  0
unconditional  0 taken 1
        1: 1285:		free(messages);
        1: 1285-block  0
unconditional  0 taken 1
        -: 1286:	}
        -: 1287:
        4: 1288:	if (ext_colors_n) {
        4: 1288-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1289:		i = (int)ext_colors_n;
      318: 1290:		while (--i >= 0)
        4: 1290-block  0
unconditional  0 taken 4
      318: 1290-block  1
branch  1 taken 314
branch  2 taken 4 (fallthrough)
      314: 1291:			free(ext_colors[i]);
      314: 1291-block  0
unconditional  0 taken 314
        4: 1292:		free(ext_colors);
        4: 1292-block  0
unconditional  0 taken 4
        -: 1293:	}
        -: 1294:
        4: 1295:	if (ws && ws[0].path) {
        4: 1295-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1295-block  1
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 1296:		i = MAX_WS;
       36: 1297:		while (--i >= 0)
        4: 1297-block  0
unconditional  0 taken 4
       36: 1297-block  1
branch  1 taken 32
branch  2 taken 4 (fallthrough)
       32: 1298:			if (ws[i].path)
       32: 1298-block  0
branch  0 taken 13 (fallthrough)
branch  1 taken 19
       13: 1299:				free(ws[i].path);
       13: 1299-block  0
unconditional  0 taken 13
        4: 1300:		free(ws);
        4: 1300-block  0
unconditional  0 taken 4
        -: 1301:	}
        -: 1302:
        4: 1303:	free(actions_file);
        4: 1304:	free(bm_file);
        4: 1305:	free(data_dir);
        4: 1306:	free(colors_dir);
        4: 1307:	free(config_dir_gral);
        4: 1308:	free(config_dir);
        4: 1309:	free(config_file);
        4: 1310:	free(dirhist_file);
        4: 1311:	free(hist_file);
        4: 1312:	free(kbinds_file);
        4: 1313:	free(log_file);
        4: 1314:	free(mime_file);
        4: 1315:	free(msg_log_file);
        4: 1316:	free(plugins_dir);
        4: 1317:	free(profile_file);
        4: 1318:	free(remotes_file);
        -: 1319:
        4: 1320:	free_remotes(1);
        4: 1320-block  0
call    0 returned 4
        -: 1321:
        -: 1322:#ifndef _NO_SUGGESTIONS
        4: 1323:	free(suggestion_buf);
        4: 1324:	free(suggestion_strategy);
        -: 1325:#endif
        -: 1326:
        4: 1327:	free(sel_file);
        4: 1328:	free(tmp_dir);
        4: 1329:	free(user.name);
        4: 1330:	free(user.home);
        4: 1331:	free(user.shell);
        -: 1332:#ifndef _NO_TRASH
        4: 1333:	free(trash_dir);
        4: 1334:	free(trash_files_dir);
        4: 1335:	free(trash_info_dir);
        -: 1336:#endif
        -: 1337:
        -: 1338:	/* Restore the color of the running terminal */
        4: 1339:	fputs("\x1b[0;39;49m", stdout);
call    0 returned 4
        4: 1340:}
        -: 1341:
        -: 1342:void
function set_signals_to_ignore called 4 returned 100% blocks executed 100%
        4: 1343:set_signals_to_ignore(void)
        -: 1344:{
        -: 1345:	/*  signal(SIGINT, signal_handler); C-c */
        4: 1346:	signal(SIGINT, SIG_IGN);  /* C-c */
        4: 1346-block  0
call    0 returned 4
        4: 1347:	signal(SIGQUIT, SIG_IGN); /* C-\ */
call    0 returned 4
        4: 1348:	signal(SIGTSTP, SIG_IGN); /* C-z */
call    0 returned 4
        -: 1349:	/*  signal(SIGTERM, SIG_IGN);
        -: 1350:	signal(SIGTTIN, SIG_IGN);
        -: 1351:	signal(SIGTTOU, SIG_IGN); */
        4: 1352:}
        -: 1353:
        -: 1354:void
function handle_stdin called 0 returned 0% blocks executed 0%
    #####: 1355:handle_stdin()
        -: 1356:{
        -: 1357:	/* If files are passed via stdin, we need to disable restore
        -: 1358:	 * last path in order to correctly understand relative paths */
    #####: 1359:	restore_last_path = 0;
        -: 1360:
        -: 1361:	/* Max input size: 512 * (512 * 1024)
        -: 1362:	 * 512 chunks of 524288 bytes (512KiB) each
        -: 1363:	 * == (65535 * PATH_MAX)
        -: 1364:	 * == 262MiB of data ((65535 * PATH_MAX) / 1024) */
        -: 1365:
    #####: 1366:	size_t chunk = 512 * 1024,
    #####: 1367:		   chunks_n = 1,
    #####: 1368:		   total_len = 0,
    #####: 1369:		   max_chunks = 512;
        -: 1370:
    #####: 1371:	ssize_t input_len = 0;
        -: 1372:
        -: 1373:	/* Initial buffer allocation == 1 chunk */
    #####: 1374:	char *buf = (char *)xnmalloc(chunk, sizeof(char));
    %%%%%: 1374-block  0
call    0 never executed
        -: 1375:
    #####: 1376:	while (chunks_n < max_chunks) {
unconditional  0 never executed
    %%%%%: 1376-block  0
branch  1 never executed
branch  2 never executed
    #####: 1377:		input_len = read(STDIN_FILENO, buf + total_len, chunk);
    %%%%%: 1377-block  0
call    0 never executed
        -: 1378:
        -: 1379:		/* Error */
    #####: 1380:		if (input_len < 0) {
branch  0 never executed
branch  1 never executed
    #####: 1381:			free(buf);
    #####: 1382:			return;
    %%%%%: 1382-block  0
unconditional  0 never executed
        -: 1383:		}
        -: 1384:
        -: 1385:		/* Nothing else to be read */
    #####: 1386:		if (input_len == 0)
    %%%%%: 1386-block  0
branch  0 never executed
branch  1 never executed
    #####: 1387:			break;
    %%%%%: 1387-block  0
unconditional  0 never executed
        -: 1388:
    #####: 1389:		total_len += (size_t)input_len;
    #####: 1390:		chunks_n++;
        -: 1391:
        -: 1392:		/* Append a new chunk of memory to the buffer */
    #####: 1393:		buf = (char *)xrealloc(buf, (chunks_n + 1) * chunk);
    %%%%%: 1393-block  0
call    0 never executed
unconditional  1 never executed
        -: 1394:	}
        -: 1395:
    #####: 1396:	if (total_len == 0)
    %%%%%: 1396-block  0
branch  0 never executed
branch  1 never executed
    #####: 1397:		goto FREE_N_EXIT;
    %%%%%: 1397-block  0
unconditional  0 never executed
        -: 1398:
        -: 1399:	/* Null terminate the input buffer */
    #####: 1400:	buf[total_len] = '\0';
        -: 1401:
        -: 1402:	/* Create tmp dir to store links to files */
    #####: 1403:	char *rand_ext = gen_rand_str(6);
    %%%%%: 1403-block  0
call    0 never executed
    #####: 1404:	if (!rand_ext)
branch  0 never executed
branch  1 never executed
    #####: 1405:		goto FREE_N_EXIT;
    %%%%%: 1405-block  0
unconditional  0 never executed
        -: 1406:
    #####: 1407:	if (tmp_dir) {
    %%%%%: 1407-block  0
branch  0 never executed
branch  1 never executed
    #####: 1408:		stdin_tmp_dir = (char *)xnmalloc(strlen(tmp_dir) + 14, sizeof(char));
    %%%%%: 1408-block  0
call    0 never executed
    #####: 1409:		sprintf(stdin_tmp_dir, "%s/clifm.%s", tmp_dir, rand_ext);
unconditional  0 never executed
        -: 1410:	} else {
    #####: 1411:		stdin_tmp_dir = (char *)xnmalloc(18, sizeof(char));
    %%%%%: 1411-block  0
call    0 never executed
    #####: 1412:		sprintf(stdin_tmp_dir, "/tmp/clifm.%s", rand_ext);
unconditional  0 never executed
        -: 1413:	}
        -: 1414:
    #####: 1415:	free(rand_ext);
        -: 1416:
    #####: 1417:	char *cmd[] = {"mkdir", "-p", stdin_tmp_dir, NULL};
    #####: 1418:	if (launch_execve(cmd, FOREGROUND, E_NOFLAG) != EXIT_SUCCESS)
    %%%%%: 1418-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1419:		goto FREE_N_EXIT;
    %%%%%: 1419-block  0
unconditional  0 never executed
        -: 1420:
        -: 1421:	/* Get CWD: we need it to prepend it to relative paths */
    #####: 1422:	char *cwd = (char *)NULL;
    #####: 1423:	cwd = getcwd(NULL, 0);
    %%%%%: 1423-block  0
call    0 never executed
    #####: 1424:	if (!cwd)
branch  0 never executed
branch  1 never executed
    #####: 1425:		goto FREE_N_EXIT;
    %%%%%: 1425-block  0
unconditional  0 never executed
        -: 1426:
        -: 1427:	/* Get substrings from buf */
    #####: 1428:	char *p = buf, *q = buf;
        -: 1429:
    #####: 1430:	while (*p) {
    %%%%%: 1430-block  0
unconditional  0 never executed
    %%%%%: 1430-block  1
branch  1 never executed
branch  2 never executed
    #####: 1431:		if (!*p || *p == '\n') {
    %%%%%: 1431-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1431-block  1
branch  2 never executed
branch  3 never executed
    #####: 1432:			*p = '\0';
        -: 1433:
        -: 1434:			/* Create symlinks (in tmp dir) to each valid file in
        -: 1435:			 * the buffer */
        -: 1436:
        -: 1437:			/* If file does not exist */
        -: 1438:			struct stat attr;
    #####: 1439:			if (lstat(q, &attr) == -1)
    %%%%%: 1439-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1440:				continue;
    %%%%%: 1440-block  0
unconditional  0 never executed
        -: 1441:
        -: 1442:			/* Construct source and destiny files */
    #####: 1443:			char *tmp_file = strrchr(q, '/');
    #####: 1444:			if (!tmp_file || !*(++tmp_file))
    %%%%%: 1444-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1444-block  1
branch  2 never executed
branch  3 never executed
    #####: 1445:				tmp_file = q;
    %%%%%: 1445-block  0
unconditional  0 never executed
        -: 1446:
        -: 1447:			char source[PATH_MAX];
    #####: 1448:			if (*q != '/' || !q[1])
    %%%%%: 1448-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1448-block  1
branch  2 never executed
branch  3 never executed
    #####: 1449:				snprintf(source, PATH_MAX, "%s/%s", cwd, q);
    %%%%%: 1449-block  0
unconditional  0 never executed
        -: 1450:			else
    #####: 1451:				xstrsncpy(source, q, PATH_MAX);
    %%%%%: 1451-block  0
call    0 never executed
unconditional  1 never executed
        -: 1452:
        -: 1453:			char dest[PATH_MAX + 1];
    #####: 1454:			snprintf(dest, PATH_MAX, "%s/%s", stdin_tmp_dir, tmp_file);
        -: 1455:
    #####: 1456:			if (symlink(source, dest) == -1)
    %%%%%: 1456-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1457:				_err('w', PRINT_PROMPT, "ln: '%s': %s\n", q, strerror(errno));
    %%%%%: 1457-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -: 1458:
    #####: 1459:			q = p + 1;
    %%%%%: 1459-block  0
unconditional  0 never executed
        -: 1460:		}
        -: 1461:
    #####: 1462:		p++;
    %%%%%: 1462-block  0
unconditional  0 never executed
        -: 1463:	}
        -: 1464:
        -: 1465:	/* chdir to tmp dir and update path var */
    #####: 1466:	if (xchdir(stdin_tmp_dir, SET_TITLE) == -1) {
    %%%%%: 1466-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1467:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, stdin_tmp_dir,
call    0 never executed
    #####: 1468:		    strerror(errno));
    %%%%%: 1468-block  0
call    0 never executed
        -: 1469:
    #####: 1470:		char *rm_cmd[] = {"rm", "-drf", stdin_tmp_dir, NULL};
    #####: 1471:		launch_execve(rm_cmd, FOREGROUND, E_NOFLAG);
call    0 never executed
        -: 1472:
    #####: 1473:		free(cwd);
    #####: 1474:		goto FREE_N_EXIT;
unconditional  0 never executed
        -: 1475:	}
        -: 1476:
    #####: 1477:	free(cwd);
        -: 1478:
    #####: 1479:	if (ws[cur_ws].path)
    %%%%%: 1479-block  0
branch  0 never executed
branch  1 never executed
    #####: 1480:		free(ws[cur_ws].path);
    %%%%%: 1480-block  0
unconditional  0 never executed
        -: 1481:
    #####: 1482:	ws[cur_ws].path = savestring(stdin_tmp_dir, strlen(stdin_tmp_dir));
    %%%%%: 1482-block  0
call    0 never executed
    #####: 1483:	goto FREE_N_EXIT;
unconditional  0 never executed
        -: 1484:
    #####: 1485:FREE_N_EXIT:
    #####: 1486:	free(buf);
        -: 1487:
        -: 1488:	/* Go back to tty */
    #####: 1489:	dup2(STDOUT_FILENO, STDIN_FILENO);
    %%%%%: 1489-block  0
call    0 never executed
        -: 1490:
    #####: 1491:	if (cd_lists_on_the_fly) {
branch  0 never executed
branch  1 never executed
    #####: 1492:		free_dirlist();
    %%%%%: 1492-block  0
call    0 never executed
    #####: 1493:		list_dir();
call    0 never executed
    #####: 1494:		add_to_dirhist(ws[cur_ws].path);
call    0 never executed
unconditional  1 never executed
        -: 1495:	}
        -: 1496:
    #####: 1497:	return;
    %%%%%: 1497-block  0
unconditional  0 never executed
        -: 1498:}
        -: 1499:
        -: 1500:int
function pin_directory called 1 returned 100% blocks executed 61%
        1: 1501:pin_directory(char *dir)
        -: 1502:{
        1: 1503:	if (!dir || !*dir)
        1: 1503-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1503-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 1504:		return EXIT_FAILURE;
    %%%%%: 1504-block  0
unconditional  0 never executed
        -: 1505:
        -: 1506:	struct stat attr;
        1: 1507:	if (lstat(dir, &attr) == -1) {
        1: 1507-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1508:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, dir, strerror(errno));
    %%%%%: 1508-block  0
call    0 never executed
call    1 never executed
    #####: 1509:		return EXIT_FAILURE;
unconditional  0 never executed
        -: 1510:	}
        -: 1511:
        1: 1512:	if (pinned_dir) {
        1: 1512-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1513:		free(pinned_dir);
    #####: 1514:		pinned_dir = (char *)NULL;
    %%%%%: 1514-block  0
unconditional  0 never executed
        -: 1515:	}
        -: 1516:
        -: 1517:	/* If absolute path */
        1: 1518:	if (*dir == '/') {
        1: 1518-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1519:		pinned_dir = savestring(dir, strlen(dir));
    %%%%%: 1519-block  0
call    0 never executed
unconditional  1 never executed
        -: 1520:	} else { /* If relative path */
        -: 1521:
        1: 1522:		if (strcmp(ws[cur_ws].path, "/") == 0) {
        1: 1522-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1523:			pinned_dir = (char *)xnmalloc(strlen(dir) + 2, sizeof(char));
    %%%%%: 1523-block  0
call    0 never executed
    #####: 1524:			sprintf(pinned_dir, "/%s", dir);
unconditional  0 never executed
        -: 1525:		} else {
        2: 1526:			pinned_dir = (char *)xnmalloc(strlen(dir)
        1: 1527:								+ strlen(ws[cur_ws].path) + 2, sizeof(char));
        1: 1527-block  0
call    0 returned 1
        1: 1528:			sprintf(pinned_dir, "%s/%s", ws[cur_ws].path, dir);
unconditional  0 taken 1
        -: 1529:		}
        -: 1530:	}
        -: 1531:
        1: 1532:	printf(_("%s: Succesfully pinned '%s'\n"), PROGRAM_NAME, dir);
        1: 1532-block  0
call    0 returned 1
call    1 returned 1
        1: 1533:	return EXIT_SUCCESS;
unconditional  0 taken 1
        -: 1534:}
        -: 1535:
        -: 1536:int
function unpin_dir called 2 returned 100% blocks executed 67%
        2: 1537:unpin_dir(void)
        -: 1538:{
        2: 1539:	if (!pinned_dir) {
        2: 1539-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1540:		printf(_("%s: No pinned file\n"), PROGRAM_NAME);
    %%%%%: 1540-block  0
call    0 never executed
call    1 never executed
    #####: 1541:		return EXIT_SUCCESS;
unconditional  0 never executed
        -: 1542:	}
        -: 1543:
        2: 1544:	if (config_dir && xargs.stealth_mode != 1) {
        2: 1544-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1544-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 1545:		int cmd_error = 0;
        2: 1546:		char *pin_file = (char *)xnmalloc(strlen(config_dir) + 7, sizeof(char));
        2: 1546-block  0
call    0 returned 2
        2: 1547:		sprintf(pin_file, "%s/.pin", config_dir);
        -: 1548:
        2: 1549:		if (unlink(pin_file) == -1) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2: 1550:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, pin_file,
call    0 returned 2
        2: 1551:			    strerror(errno));
        2: 1551-block  0
call    0 returned 2
        2: 1552:			cmd_error = 1;
unconditional  0 taken 2
        -: 1553:		}
        -: 1554:
        2: 1555:		free(pin_file);
        2: 1556:		if (cmd_error)
        2: 1556-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1557:			return EXIT_FAILURE;
        2: 1557-block  0
unconditional  0 taken 2
        -: 1558:	}
        -: 1559:
    #####: 1560:	printf(_("Succesfully unpinned %s\n"), pinned_dir);
    %%%%%: 1560-block  0
call    0 never executed
call    1 never executed
        -: 1561:
    #####: 1562:	free(pinned_dir);
    #####: 1563:	pinned_dir = (char *)NULL;
    #####: 1564:	return EXIT_SUCCESS;
unconditional  0 never executed
        -: 1565:}
        -: 1566:
        -: 1567:int
function hidden_function called 3 returned 100% blocks executed 85%
        3: 1568:hidden_function(char **comm)
        -: 1569:{
        3: 1570:	int exit_status = EXIT_SUCCESS;
        -: 1571:
        3: 1572:	if (strcmp(comm[1], "status") == 0) {
        3: 1572-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1: 1573:		printf(_("%s: Hidden files %s\n"), PROGRAM_NAME,
        1: 1573-block  0
call    0 returned 1
call    1 returned 1
unconditional  2 taken 1
       1*: 1574:		    (show_hidden) ? _("enabled") : _("disabled"));
        1: 1574-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1574-block  1
call    2 returned 1
unconditional  3 taken 1
    %%%%%: 1574-block  2
call    4 never executed
unconditional  5 never executed
        2: 1575:	} else if (strcmp(comm[1], "off") == 0) {
        2: 1575-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 1576:		if (show_hidden == 1) {
        1: 1576-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1577:			show_hidden = 0;
        -: 1578:
        1: 1579:			if (cd_lists_on_the_fly) {
        1: 1579-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1580:				free_dirlist();
        1: 1580-block  0
call    0 returned 1
        1: 1581:				exit_status = list_dir();
call    0 returned 1
unconditional  1 taken 1
        -: 1582:			}
        -: 1583:		}
        1: 1584:	} else if (strcmp(comm[1], "on") == 0) {
        1: 1584-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1585:		if (show_hidden == 0) {
        1: 1585-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1586:			show_hidden = 1;
        -: 1587:
        1: 1588:			if (cd_lists_on_the_fly) {
        1: 1588-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1589:				free_dirlist();
        1: 1589-block  0
call    0 returned 1
        1: 1590:				exit_status = list_dir();
call    0 returned 1
unconditional  1 taken 1
        -: 1591:			}
        -: 1592:		}
        -: 1593:	} else {
    #####: 1594:		fprintf(stderr, "%s\n", _(HF_USAGE));
    %%%%%: 1594-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -: 1595:	}
        -: 1596:
        3: 1597:	return exit_status;
        3: 1597-block  0
unconditional  0 taken 3
        -: 1598:}
        -: 1599:
        -: 1600:/* Instead of recreating here the commands description, just jump to the
        -: 1601: * corresponding section in the manpage */
        -: 1602:int
function list_commands called 1 returned 100% blocks executed 83%
        1: 1603:list_commands(void)
        -: 1604:{
        -: 1605:	char cmd[PATH_MAX];
        1: 1606:	snprintf(cmd, PATH_MAX - 1, "export PAGER=\"less -p '^[0-9]+\\.[[:space:]]COMMANDS'\"; man %s\n",
        -: 1607:			PNL);
        1: 1608:	if (launch_execle(cmd) != EXIT_SUCCESS)
        1: 1608-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####: 1609:		return EXIT_FAILURE;
    %%%%%: 1609-block  0
unconditional  0 never executed
        -: 1610:
        1: 1611:	return EXIT_SUCCESS;
        1: 1611-block  0
unconditional  0 taken 1
        -: 1612:}
        -: 1613:
        -: 1614:void
function help_function called 38 returned 100% blocks executed 95%
       38: 1615:help_function(void)
        -: 1616:{
       38: 1617:	fputs("\x1b[0m", stdout);
       38: 1617-block  0
call    0 returned 38
      38*: 1618:	printf(_("%s%s %s (%s), by %s\n"), (flags & EXT_HELP) ? "" : df_c,
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    %%%%%: 1618-block  0
unconditional  2 never executed
       38: 1618-block  1
unconditional  3 taken 38
       38: 1618-block  2
call    4 returned 38
call    5 returned 38
        -: 1619:			PROGRAM_NAME, VERSION, DATE, AUTHOR);
        -: 1620:
       38: 1621:	printf(_("\nUSAGE: %s %s\n\
call    0 returned 38
call    1 returned 38
        -: 1622:\n -a, --no-hidden\t\t do not show hidden files (default)\
        -: 1623:\n -A, --show-hidden\t\t show hidden files\
        -: 1624:\n -b, --bookmarks-file=FILE\t specify an alternative bookmarks file\
        -: 1625:\n -c, --config-file=FILE\t\t specify an alternative configuration file\
        -: 1626:\n -D, --config-dir=DIR\t\t specify an alternative configuration directory\
        -: 1627:\n -e, --no-eln\t\t\t do not print ELN (entry list number) at \
        -: 1628:\n              the left of each file name \
        -: 1629:\n -f, --no-folders-first\t\t do not list folders first\
        -: 1630:\n -F, --folders-first\t\t list folders first (default)\
        -: 1631:\n -g, --pager\t\t\t enable the pager\
        -: 1632:\n -G, --no-pager\t\t\t disable the pager (default)\
        -: 1633:\n -h, --help\t\t\t show this help and exit\
        -: 1634:\n -i, --no-case-sensitive\t no case-sensitive files listing (default)\
        -: 1635:\n -I, --case-sensitive\t\t case-sensitive files listing\
        -: 1636:\n -k, --keybindings-file=FILE\t specify an alternative keybindings file\
        -: 1637:\n -l, --no-long-view\t\t disable long view mode (default)\
        -: 1638:\n -L, --long-view\t\t enable long view mode\
        -: 1639:\n -m, --dihist-map\t\t enable the directory history map\
        -: 1640:\n -o, --no-list-on-the-fly\t 'cd' works as the shell 'cd' command\
        -: 1641:\n -O, --list-on-the-fly\t\t 'cd' lists files on the fly (default)\
        -: 1642:\n -p, --path=PATH\t\t (Deprecated: use positional parameters instead)\
        -: 1643:\n              use PATH as %s starting path\
        -: 1644:\n -P, --profile=PROFILE\t\t use (or create) PROFILE as profile\
        -: 1645:\n -s, --splash \t\t\t enable the splash screen\
        -: 1646:\n -S, --stealth-mode \t\t leave no trace on the host system.\
        -: 1647:\n              Nothing is read from any file nor any file \
        -: 1648:\n              is created: all settings are set to the \
        -: 1649:\n              default value. However, most settings can \
        -: 1650:\n              be controlled via command line options\
        -: 1651:\n -u, --no-unicode \t\t disable unicode\
        -: 1652:\n -U, --unicode \t\t\t enable unicode to correctly list file names \
        -: 1653:\n              containing accents, tildes, umlauts, \
        -: 1654:\n              non-latin letters, etc. This option is \
        -: 1655:\n              enabled by default\
        -: 1656:\n -v, --version\t\t\t show version details and exit\
        -: 1657:\n -w, --workspace=NUM\t\t start in workspace NUM\
        -: 1658:\n -x, --no-ext-cmds\t\t disallow the use of external commands\
        -: 1659:\n -y, --light-mode\t\t enable the light mode\
        -: 1660:\n -z, --sort=METHOD\t\t sort files by METHOD, where METHOD \
        -: 1661:\n              could be: 0 = none, 1 = name, 2 = size, \
        -: 1662:\n              3 = atime, 4 = btime, 5 = ctime, \
        -: 1663:\n              6 = mtime, 7 = version, 8 = extension, \
        -: 1664:\n              9 = inode, 10 = owner, 11 = group"),
        -: 1665:	    PNL, GRAL_USAGE, PROGRAM_NAME);
        -: 1666:
       38: 1667:	printf("\
call    0 returned 38
        -: 1668:\n     --autojump\t enable the autojump function (run the directory \
        -: 1669:\n              jumper omitting the j command: 'STR...' == 'j STR...')\
        -: 1670:\n     --case-sens-dirjump\t do not ignore case when consulting the \
        -: 1671:\n              jump database (via the 'j' command)\
        -: 1672:\n     --case-sens-path-comp\t enable case sensitive path completion\
        -: 1673:\n     --cd-on-quit\t\t write last visited path to \
        -: 1674:\n              $XDG_CONFIG_HOME/clifm/.last to be accessed\
        -: 1675:\n              later by a shell funtion. See the manpage\
        -: 1676:\n     --color-scheme=NAME\t use color scheme NAME\
        -: 1677:\n     --cwd-in-title\t\t print current directory in terminal \
        -: 1678:\n              window title\
        -: 1679:\n     --disk-usage\t\t show disk usage (free/total) for the\
        -: 1680:\n              filesystem to which the current directory \
        -: 1681:\n              belongs\
        -: 1682:\n     --enable-logs\t\t enable program logs\
        -: 1683:\n     --expand-bookmarks\t\t expand bookmark names into the \
        -: 1684:\n              corresponding bookmark paths. TAB \
        -: 1685:\n              completion for bookmark names is also \
        -: 1686:\n              available\
        -: 1687:\n     --icons\t\t\t enable icons\
        -: 1688:\n     --icons-use-file-color\t icons color follows file color\
        -: 1689:\n     --list-and-quit\t\t list files and quit. It may be used\
        -: 1690:\n              in conjunction with -p\
        -: 1691:\n     --max-dirhist\t\t maximum number of visited directories to \
        -: 1692:\n              remember\
        -: 1693:\n     --max-files=NUM\t\t list only up to NUM files\
        -: 1694:\n     --max-path=NUM\t\t set the maximun number of characters \
        -: 1695:\n              after which the current directory in the \
        -: 1696:\n              prompt line will be abreviated to the \
        -: 1697:\n              directory base name (if \\z is used in \
        -: 1698:\n              the prompt\
        -: 1699:\n     --no-dir-jumper\t\t disable the directory jumper function\
        -: 1700:\n     --no-cd-auto\t\t by default, %s changes to directories \
        -: 1701:\n\t\t\t\tby just specifying the corresponding ELN \
        -: 1702:\n              (e.g. '12' instead of 'cd 12'). This \
        -: 1703:\n              option forces the use of 'cd'\
        -: 1704:\n     --no-classify\t\t do not append file type indicators\
        -: 1705:\n     --no-clear-screen\t\t do not clear the screen when listing \
        -: 1706:\n              directories\
        -: 1707:\n     --no-colors\t\t disable file type colors for files listing \
        -: 1708:\n     --no-columns\t\t disable columned files listing\
        -: 1709:\n     --no-file-cap\t\t do not check files capabilities when\
        -: 1710:\n              listing files\
        -: 1711:\n     --no-file-ext\t\t do not check files extension when\
        -: 1712:\n              listing files\
        -: 1713:\n     --no-files-counter\t\t disable the files counter for \
        -: 1714:\n              directories. This option is especially \
        -: 1715:\n              useful to speed up the listing process; \
        -: 1716:\n              counting files in directories is expensive\
        -: 1717:\n     --no-follow-symlink\t do not follow symbolic links when\
        -: 1718:\n              listing files\
        -: 1719:\n     --no-open-auto\t\t same as no-cd-auto, but for files\
        -: 1720:\n     --no-tips\t\t\t disable startup tips\
        -: 1721:\n     --no-restore-last-path\t save last visited directory to be \
        -: 1722:\n              restored in the next session\
        -: 1723:\n     --no-suggestions\t\t disable auto-suggestions\
        -: 1724:\n     --no-welcome-message\t disable the welcome message\
        -: 1725:\n     --only-dirs\t\t list only directories and symbolic links\
        -: 1726:\n              to directories\
        -: 1727:\n     --open=FILE\t run as a stand-alone resource opener: open\
        -: 1728:\n              FILE and exit\
        -: 1729:\n     --opener=APPLICATION\t resource opener to use instead of 'lira',\
        -: 1730:\n              %s built-in opener\
        -: 1731:\n     --print-sel\t\t keep the list of selected files in sight\
        -: 1732:\n     --rl-vi-mode\t\t set readline to vi editing mode (defaults \
        -: 1733:\n              to emacs editing mode)\
        -: 1734:\n     --share-selbox\t\t make the Selection Box common to \
        -: 1735:\n              different profiles\
        -: 1736:\n     --sort-reverse\t\t sort in reverse order, for example: z-a \
        -: 1737:\n              instead of a-z, which is the default order)\
        -: 1738:\n     --trash-as-rm\t\t the 'r' command executes 'trash' instead of \
        -: 1739:				'rm' to prevent accidental deletions\n",
        -: 1740:	    PROGRAM_NAME, PROGRAM_NAME);
        -: 1741:
       38: 1742:	printf(_("\nBUILT-IN COMMANDS:\n\nThe following is just a brief list of "
call    0 returned 38
call    1 returned 38
        -: 1743:			"available commands and possible parameters.\n\nFor a complete "
        -: 1744:			"description of each of these commands run 'cmd' (or press "
        -: 1745:			"F2) or consult the manpage (F1).\n\nYou can also try "
        -: 1746:			"the 'ih' action to run the interactive help plugin (it "
        -: 1747:			"depends on FZF). Just enter 'ih', that's it.\n\nIt is also "
        -: 1748:			"recommended to consult the project's wiki "
        -: 1749:			"(https://github.com/leo-arch/clifm/wiki)\n\n"));
        -: 1750:
       38: 1751:	puts(_("ELN/FILE/DIR (auto-open and autocd functions)\n\
call    0 returned 38
call    1 returned 38
        -: 1752: /PATTERN [DIR] [-filetype] [-x] (quick search)\n\
        -: 1753: ;[CMD], :[CMD] (run CMD via the system shell)\n\
        -: 1754: ac, ad ELN/FILE ... (archiving functions)\n\
        -: 1755: acd, autocd [on, off, status]\n\
        -: 1756: actions [edit]\n\
        -: 1757: alias [import FILE]\n\
        -: 1758: ao, auto-open [on, off, status]\n\
        -: 1759: b, back [h, hist] [clear] [!ELN]\n\
        -: 1760: bl ELN/FILE ... (batch links)\n\
        -: 1761: bm, bookmarks [a, add PATH] [d, del] [edit] [SHORTCUT or NAME]\n\
        -: 1762: br, bulk ELN/FILE ...\n\
        -: 1763: c, l [e, edit], m, md, r (copy, link, move, makedir, and remove)\n\
        -: 1764: cc, colors\n\
        -: 1765: cd [ELN/DIR]\n\
        -: 1766: cl, columns [on, off]\n\
        -: 1767: cmd, commands\n\
        -: 1768: cs, colorscheme [edit] [COLORSCHEME]\n\
        -: 1769: d, dup SOURCE [DEST]\n\
        -: 1770: ds, desel [*, a, all]\n\
        -: 1771: edit [APPLICATION] [reset]\n\
        -: 1772: exp, export [ELN/FILE ...]\n\
        -: 1773: ext [on, off, status]\n\
        -: 1774: f, forth [h, hist] [clear] [!ELN]\n\
        -: 1775: fc, filescounter [on, off, status]\n\
        -: 1776: ff, folders-first [on, off, status]\n\
        -: 1777: fs\n\
        -: 1778: ft, filter [unset] [REGEX]\n\
        -: 1779: hf, hidden [on, off, status]\n\
        -: 1780: history [clear] [-n]\n\
        -: 1781: icons [on, off]\n\
        -: 1782: j, jc, jp, jl [STRING ...] jo [NUM], je (directory jumper function)\n\
        -: 1783: kb, keybinds [edit] [reset] [readline]\n\
        -: 1784: lm [on, off] (lightmode)\n\
        -: 1785: log [clear]\n\
        -: 1786: mf NUM (List up to NUM files)\n\
        -: 1787: mm, mime [info ELN/FILE] [edit] [import] (resource opener)\n\
        -: 1788: mp, mountpoints\n\
        -: 1789: msg, messages [clear]\n\
        -: 1790: n, new FILE DIR/ ...n\n\
        -: 1791: net [NAME] [edit] [m, mount NAME] [u, unmount NAME]\n\
        -: 1792: o, open [ELN/FILE] [APPLICATION]\n\
        -: 1793: opener [default] [APPLICATION]\n\
        -: 1794: p, pr, pp, prop [ELN/FILE ... n]\n\
        -: 1795: path, cwd\n\
        -: 1796: pf, prof, profile [ls, list] [set, add, del PROFILE]\n\
        -: 1797: pg, pager [on, off, status]\n\
        -: 1798: pin [FILE/DIR]\n\
        -: 1799: q, quit, exit\n\
        -: 1800: Q\n\
        -: 1801: rf, refresh\n\
        -: 1802: rl, reload\n\
        -: 1803: s, sel ELN/FILE... [[!]PATTERN] [-FILETYPE] [:PATH]\n\
        -: 1804: sb, selbox\n\
        -: 1805: shell [SHELL]\n\
        -: 1806: splash\n\
        -: 1807: st, sort [METHOD] [rev]\n\
        -: 1808: t, tr, trash [ELN/FILE ... n] [ls, list] [clear] [del, rm]\n\
        -: 1809: te [FILE(s)]\n\
        -: 1810: tips\n\
        -: 1811: u, undel, untrash [*, a, all]\n\
        -: 1812: uc, unicode [on, off, status]\n\
        -: 1813: unpin\n\
        -: 1814: v, vv, paste sel [DESTINY]\n\
        -: 1815: ver, version\n\
        -: 1816: ws [NUM, +, -] (workspaces)\n\
        -: 1817: x, X [ELN/DIR] (new instance)\n"));
        -: 1818:
       38: 1819:	printf(_("DEFAULT KEYBOARD SHORTCUTS:\n\n"
call    0 returned 38
call    1 returned 38
        -: 1820:		 " Right, C-f: Accept the entire suggestion\n\
        -: 1821: M-Right, M-f: Accept the first suggested word\n\
        -: 1822: M-c: Clear the current command line buffer\n\
        -: 1823: M-g: Toggle list-folders-first on/off\n\
        -: 1824: C-r: Refresh the screen\n\
        -: 1825: M-l: Toggle long view mode on/off\n\
        -: 1826: M-m: List mountpoints\n\
        -: 1827: M-t: Clear messages\n\
        -: 1828: M-h: Show directory history\n\
        -: 1829: M-i, M-.: Toggle hidden files on/off\n\
        -: 1830: M-s: Open the Selection Box\n\
        -: 1831: M-a: Select all files in the current working directory\n\
        -: 1832: M-d: Deselect all selected files\n\
        -: 1833: M-r: Change to the root directory\n\
        -: 1834: M-e, Home: Change to the home directory\n\
        -: 1835: M-u, S-Up: Change to the parent directory\n\
        -: 1836: M-j, S-Left: Change to previous visited directory\n\
        -: 1837: M-k, S-Right: Change to next visited directory\n\
        -: 1838: M-o: Lock terminal\n\
        -: 1839: M-p: Change to pinned directory\n\
        -: 1840: M-1: Switch to workspace 1\n\
        -: 1841: M-2: Switch to workspace 2\n\
        -: 1842: M-3: Switch to workspace 3\n\
        -: 1843: M-4: Switch to workspace 4\n\
        -: 1844: C-M-j: Change to first visited directory\n\
        -: 1845: C-M-k: Change to last visited directory\n\
        -: 1846: C-M-o: Switch to previous profile\n\
        -: 1847: C-M-p: Switch to next profile\n\
        -: 1848: C-M-a: Archive selected files\n\
        -: 1849: C-M-e: Export selected files\n\
        -: 1850: C-M-r: Rename selected files\n\
        -: 1851: C-M-d: Remove selected files\n\
        -: 1852: C-M-t: Trash selected files\n\
        -: 1853: C-M-u: Restore trashed files\n\
        -: 1854: C-M-b: Bookmark last selected file or directory\n\
        -: 1855: C-M-g: Open/change-into last selected file/directory\n\
        -: 1856: C-M-n: Move selected files into the current working directory\n\
        -: 1857: C-M-v: Copy selected files into the current working directory\n\
        -: 1858: M-y: Toggle light mode on/off\n\
        -: 1859: M-z: Switch to previous sorting method\n\
        -: 1860: M-x: Switch to next sorting method\n\
        -: 1861: C-x: Launch a new instance\n\
        -: 1862: F1: Manual page\n\
        -: 1863: F2: Commands help\n\
        -: 1864: F3: Keybindings help\n\
        -: 1865: F6: Open the MIME list file\n\
        -: 1866: F7: Open the jump database file\n\
        -: 1867: F8: Open the current color scheme file\n\
        -: 1868: F9: Open the keybindings file\n\
        -: 1869: F10: Open the configuration file\n\
        -: 1870: F11: Open the bookmarks file\n\
        -: 1871: F12: Quit\n\n"
        -: 1872:		 "NOTE: C stands for Ctrl, S for Shift, and M for Meta (Alt key in "
        -: 1873:		 "most keyboards)\n\n"));
        -: 1874:
       38: 1875:	puts(_("Run the 'colors' or 'cc' command to see the list "
call    0 returned 38
call    1 returned 38
        -: 1876:	       "of currently used color codes.\n"));
        -: 1877:
       38: 1878:	puts(_("The configuration and profile files allow you to customize "
call    0 returned 38
call    1 returned 38
        -: 1879:	       "colors, define some prompt commands and aliases, and more. "
        -: 1880:	       "For a full description consult the manpage."));
       38: 1881:}
        -: 1882:
        -: 1883:void
function free_software called 1 returned 100% blocks executed 100%
        1: 1884:free_software(void)
        -: 1885:{
        1: 1886:	puts(_("Excerpt from 'What is Free Software?', by Richard Stallman. \
        1: 1886-block  0
call    0 returned 1
call    1 returned 1
        -: 1887:Source: https://www.gnu.org/philosophy/free-sw.html\n \
        -: 1888:\n\"'Free software' means software that respects users' freedom and \
        -: 1889:community. Roughly, it means that the users have the freedom to run, \
        -: 1890:copy, distribute, study, change and improve the software. Thus, 'free \
        -: 1891:software' is a matter of liberty, not price. To understand the concept, \
        -: 1892:you should think of 'free' as in 'free speech', not as in 'free beer'. \
        -: 1893:We sometimes call it 'libre software', borrowing the French or Spanish \
        -: 1894:word for 'free' as in freedom, to show we do not mean the software is \
        -: 1895:gratis.\n\
        -: 1896:\nWe campaign for these freedoms because everyone deserves them. With \
        -: 1897:these freedoms, the users (both individually and collectively) control \
        -: 1898:the program and what it does for them. When users don't control the \
        -: 1899:program, we call it a 'nonfree' or proprietary program. The nonfree \
        -: 1900:program controls the users, and the developer controls the program; \
        -: 1901:this makes the program an instrument of unjust power. \n\
        -: 1902:\nA program is free software if the program's users have the four \
        -: 1903:essential freedoms:\n\n\
        -: 1904:- The freedom to run the program as you wish, for any purpose \
        -: 1905:(freedom 0).\n\
        -: 1906:- The freedom to study how the program works, and change it so it does \
        -: 1907:your computing as you wish (freedom 1). Access to the source code is a \
        -: 1908:precondition for this.\n\
        -: 1909:- The freedom to redistribute copies so you can help your neighbor \
        -: 1910:(freedom 2).\n\
        -: 1911:- The freedom to distribute copies of your modified versions to others \
        -: 1912:(freedom 3). By doing this you can give the whole community a chance to \
        -: 1913:benefit from your changes. Access to the source code is a precondition \
        -: 1914:for this. \n\
        -: 1915:\nA program is free software if it gives users adequately all of these \
        -: 1916:freedoms. Otherwise, it is nonfree. While we can distinguish various \
        -: 1917:nonfree distribution schemes in terms of how far they fall short of \
        -: 1918:being free, we consider them all equally unethical (...)\""));
        1: 1919:}
        -: 1920:
        -: 1921:void
function version_function called 1 returned 100% blocks executed 100%
        1: 1922:version_function(void)
        -: 1923:{
        1: 1924:	printf(_("%s %s (%s), by %s\nContact: %s\nWebsite: "
        1: 1924-block  0
call    0 returned 1
call    1 returned 1
        -: 1925:		 "%s\nLicense: %s\n"), PROGRAM_NAME, VERSION, DATE,
        -: 1926:	    AUTHOR, CONTACT, WEBSITE, LICENSE);
        1: 1927:}
        -: 1928:
        -: 1929:void
function splash called 1 returned 100% blocks executed 60%
        1: 1930:splash(void)
        -: 1931:{
        1: 1932:	printf("\n%s"
        1: 1932-block  0
call    0 returned 1
        -: 1933:"     .okkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkd. \n"
        -: 1934:"    'kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkc\n"
        -: 1935:"    xkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n"
        -: 1936:"    xkkkkkc::::::::::::::::::dkkkkkkc:::::kkkkkk\n"
        -: 1937:"    xkkkkk'..................okkkkkk'.....kkkkkk\n"
        -: 1938:"    xkkkkk'..................okkkkkk'.....kkkkkk\n"
        -: 1939:"    xkkkkk'.....okkkkkk,.....okkkkkk'.....kkkkkk\n"
        -: 1940:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1941:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1942:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1943:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1944:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1945:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1946:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1947:"    xkkkkk'.....dkkkkkk;.....okkkkkk'.....kkkkkk\n"
        -: 1948:"    xkkkkk'.....coooooo'.....:llllll......kkkkkk\n"
        -: 1949:"    xkkkkk'...............................kkkkkk\n"
        -: 1950:"    xkkkkk'...............................kkkkkk\n"
        -: 1951:"    xkkkkklccccccccccccccccccccccccccccccckkkkkk\n"
        -: 1952:"    lkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkx\n"
        -: 1953:"     ;kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkc \n"
        -: 1954:"        :c::::::::::::::::::::::::::::::::::.",
        -: 1955:	D_CYAN);
        -: 1956:
        1: 1957:	printf(_("\n\n%s%s\t\t       CliFM%s\n\tThe KISS/non-curses file manager\n"),
call    0 returned 1
call    1 returned 1
        -: 1958:	    df_c, BOLD, df_c);
        -: 1959:
        1: 1960:	if (splash_screen) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1961:		printf(_("\n\t\t\tPress any key to continue... "));
    %%%%%: 1961-block  0
call    0 never executed
call    1 never executed
    #####: 1962:		xgetchar();
call    0 never executed
    #####: 1963:		putchar('\n');
call    0 never executed
unconditional  1 never executed
        -: 1964:	} else {
        1: 1965:		putchar('\n');
        1: 1965-block  0
call    0 returned 1
unconditional  1 taken 1
        -: 1966:	}
        1: 1967:}
        -: 1968:
        -: 1969:void
function bonus_function called 0 returned 0% blocks executed 0%
    #####: 1970:bonus_function(void)
        -: 1971:{
    #####: 1972:	char *phrases[] = {
        -: 1973:	    "\"Vamos Boca Juniors Carajo!\" (La mitad + 1)",
        -: 1974:	    "\"Hey! Look behind you! A three-headed monkey! (G. Threepweed)",
        -: 1975:	    "\"Free as in free speech, not as in free beer\" (R. M. S)",
        -: 1976:	    "\"Nothing great has been made in the world without passion\" (G. W. F. Hegel)",
        -: 1977:	    "\"Simplicity is the ultimate sophistication\" (Leo Da Vinci)",
        -: 1978:	    "\"Yo vend semillas de alambre de pa, al contado, y me lo agradecieron\" (Marquitos, 9 Reinas)",
        -: 1979:	    "\"I'm so happy, because today I've found my friends, they're in my head\" (K. D. Cobain)",
        -: 1980:	    "\"The best code is written with the delete key (Someone, somewhere, sometime)",
        -: 1981:	    "\"I'm selling these fine leather jackets (Indy)",
        -: 1982:	    "\"I pray to God to make me free of God\" (Meister Eckhart)",
        -: 1983:	    "Truco y quiero retruco mierda!",
        -: 1984:	    "The only truth is that there is no truth",
        -: 1985:	    "\"This is a lie\" (The liar paradox)",
        -: 1986:	    "\"There are two ways to write error-free programs; only the third one works\" (Alan J. Perlis)",
        -: 1987:	    "The man who sold the world was later sold by the big G",
        -: 1988:	    "A programmer is always one year older than herself",
        -: 1989:	    "A smartphone is anything but smart",
        -: 1990:	    "And he did it: he killed the one who killed him",
        -: 1991:	    ">++('>",
        -: 1992:	    ":(){:|:&};:",
        -: 1993:	    "Keep it simple, stupid",
        -: 1994:	    "If ain't broken, brake it",
        -: 1995:	    "An Archer knows her target like the back of her hands",
        -: 1996:	    "\"I only know that I know nothing\" (Socrates)",
        -: 1997:	    "(Learned) Ignorance is the true outcome of wisdom (Nicholas "
        -: 1998:	    "of Cusa)",
        -: 1999:	    "True intelligence is about questions, not about answers",
        -: 2000:	    "Humanity is just an arrow released towards God",
        -: 2001:	    "Buzz is right: infinity is our only and ultimate goal",
        -: 2002:	    "That stain will never ever be erased (La 12)",
        -: 2003:	    "\"A work of art is never finished, but adandoned\" (J. L. Guerrero)",
        -: 2004:	    "At the beginning, software was hardware; but today hardware is "
        -: 2005:	    "being absorbed by software",
        -: 2006:	    NULL};
        -: 2007:
    #####: 2008:	size_t num = (sizeof(phrases) / sizeof(phrases[0])) - 1;
    #####: 2009:	srand((unsigned int)time(NULL));
    %%%%%: 2009-block  0
call    0 never executed
call    1 never executed
    #####: 2010:	puts(phrases[rand() % (int)num]);
call    0 never executed
call    1 never executed
    #####: 2011:}
